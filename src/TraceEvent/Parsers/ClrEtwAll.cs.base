using System;
using System.Diagnostics;
using System.Diagnostics.Tracing;
using System.Text;
using Microsoft.Diagnostics.Tracing;
using Address = System.UInt64;

#pragma warning disable 1591        // disable warnings on XML comments not being present

// This code was automatically generated by the TraceParserGen tool, which converts
// an ETW event manifest into strongly typed C# classes.
namespace Microsoft.Diagnostics.Tracing.Parsers
{
    using Microsoft.Diagnostics.Tracing.Parsers.MicrosoftWindowsDotNETRuntime;

    [System.CodeDom.Compiler.GeneratedCode("traceparsergen", "2.0")]
    public sealed class MicrosoftWindowsDotNETRuntimeTraceEventParser : TraceEventParser 
    {
        public static string ProviderName = "Microsoft-Windows-DotNETRuntime";
        public static Guid ProviderGuid = new Guid(unchecked((int) 0xe13c0d23), unchecked((short) 0xccbc), unchecked((short) 0x4e12), 0x93, 0x1b, 0xd9, 0xcc, 0x2e, 0xee, 0x27, 0xe4);
        public enum Keywords : long
        {
            Gc = 0x1,
            Gchandle = 0x2,
            Binder = 0x4,
            Loader = 0x8,
            Jit = 0x10,
            Ngen = 0x20,
            Startenumeration = 0x40,
            Stopenumeration = 0x80,
            Security = 0x400,
            Appdomainresourcemanagement = 0x800,
            Jittracing = 0x1000,
            Interop = 0x2000,
            Contention = 0x4000,
            Exception = 0x8000,
            Threading = 0x10000,
            Jittedmethodiltonativemap = 0x20000,
            Overrideandsuppressngenevents = 0x40000,
            Type = 0x80000,
            Gcheapdump = 0x100000,
            Gcsampledobjectallocationhigh = 0x200000,
            Gcheapsurvivalandmovement = 0x400000,
            Gcheapcollect = 0x800000,
            Gcheapandtypenames = 0x1000000,
            Gcsampledobjectallocationlow = 0x2000000,
            Perftrack = 0x20000000,
            Stack = 0x40000000,
            Threadtransfer = 0x80000000,
            Debugger = 0x100000000,
        };

        public MicrosoftWindowsDotNETRuntimeTraceEventParser(TraceEventSource source) : base(source) {}

        public event Action<ThreadTerminatedOrTransition> AppDomainResourceManagementDomainEnter
        {
            add
            {
                source.RegisterEventTemplate(AppDomainResourceManagementDomainEnterTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 87, ProviderGuid);
            }
        }
        public event Action<AppDomainMemAllocated> AppDomainResourceManagementMemAllocated
        {
            add
            {
                source.RegisterEventTemplate(AppDomainResourceManagementMemAllocatedTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 83, ProviderGuid);
            }
        }
        public event Action<AppDomainMemSurvived> AppDomainResourceManagementMemSurvived
        {
            add
            {
                source.RegisterEventTemplate(AppDomainResourceManagementMemSurvivedTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 84, ProviderGuid);
            }
        }
        public event Action<ThreadCreated> AppDomainResourceManagementThreadCreated
        {
            add
            {
                source.RegisterEventTemplate(AppDomainResourceManagementThreadCreatedTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 85, ProviderGuid);
            }
        }
        public event Action<ThreadTerminatedOrTransition> AppDomainResourceManagementThreadTerminated
        {
            add
            {
                source.RegisterEventTemplate(AppDomainResourceManagementThreadTerminatedTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 86, ProviderGuid);
            }
        }
        public event Action<AuthenticodeVerification> AuthenticodeVerificationStart
        {
            add
            {
                source.RegisterEventTemplate(AuthenticodeVerificationStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 183, ProviderGuid);
            }
        }
        public event Action<AuthenticodeVerification> AuthenticodeVerificationStop
        {
            add
            {
                source.RegisterEventTemplate(AuthenticodeVerificationStopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 184, ProviderGuid);
            }
        }
        public event Action<ModuleRange> ClrPerfTrackModuleRangeLoad
        {
            add
            {
                source.RegisterEventTemplate(ClrPerfTrackModuleRangeLoadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 158, ProviderGuid);
            }
        }
        public event Action<ClrStackWalk> ClrStackWalk
        {
            add
            {
                source.RegisterEventTemplate(ClrStackWalkTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 82, ProviderGuid);
            }
        }
        public event Action<EmptyTraceData> ContentionStart
        {
            add
            {
                source.RegisterEventTemplate(ContentionStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 81, ProviderGuid);
            }
        }
        public event Action<Contention> ContentionStop
        {
            add
            {
                source.RegisterEventTemplate(ContentionStopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 91, ProviderGuid);
            }
        }
        public event Action<EmptyTraceData> DebugExceptionProcessingStart
        {
            add
            {
                source.RegisterEventTemplate(DebugExceptionProcessingStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 242, ProviderGuid);
            }
        }
        public event Action<EmptyTraceData> DebugExceptionProcessingStop
        {
            add
            {
                source.RegisterEventTemplate(DebugExceptionProcessingStopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 243, ProviderGuid);
            }
        }
        public event Action<EmptyTraceData> DebugIPCEventStart
        {
            add
            {
                source.RegisterEventTemplate(DebugIPCEventStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 240, ProviderGuid);
            }
        }
        public event Action<EmptyTraceData> DebugIPCEventStop
        {
            add
            {
                source.RegisterEventTemplate(DebugIPCEventStopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 241, ProviderGuid);
            }
        }
        public event Action<EmptyTraceData> ExceptionStart
        {
            add
            {
                source.RegisterEventTemplate(ExceptionStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 80, ProviderGuid);
            }
        }
        public event Action<GCAllocationTick> GCAllocationTick
        {
            add
            {
                source.RegisterEventTemplate(GCAllocationTickTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 10, ProviderGuid);
            }
        }
        public event Action<EmptyTraceData> GCCreateConcurrentThread
        {
            add
            {
                source.RegisterEventTemplate(GCCreateConcurrentThreadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 11, ProviderGuid);
            }
        }
        public event Action<GCCreateSegment> GCCreateSegment
        {
            add
            {
                source.RegisterEventTemplate(GCCreateSegmentTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 5, ProviderGuid);
            }
        }
        public event Action<DecreaseMemoryPressure> GCDecreaseMemoryPressure
        {
            add
            {
                source.RegisterEventTemplate(GCDecreaseMemoryPressureTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 201, ProviderGuid);
            }
        }
        public event Action<DestroyGCHandle> GCDestoryGCHandle
        {
            add
            {
                source.RegisterEventTemplate(GCDestoryGCHandleTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 31, ProviderGuid);
            }
        }
        public event Action<FinalizeObject> GCFinalizeObject
        {
            add
            {
                source.RegisterEventTemplate(GCFinalizeObjectTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 29, ProviderGuid);
            }
        }
        public event Action<EmptyTraceData> GCFinalizersStart
        {
            add
            {
                source.RegisterEventTemplate(GCFinalizersStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 14, ProviderGuid);
            }
        }
        public event Action<GCFinalizersEnd> GCFinalizersStop
        {
            add
            {
                source.RegisterEventTemplate(GCFinalizersStopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 13, ProviderGuid);
            }
        }
        public event Action<GCFreeSegment> GCFreeSegment
        {
            add
            {
                source.RegisterEventTemplate(GCFreeSegmentTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 6, ProviderGuid);
            }
        }
        public event Action<GCBulkEdge> GCGCBulkEdge
        {
            add
            {
                source.RegisterEventTemplate(GCGCBulkEdgeTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 19, ProviderGuid);
            }
        }
        public event Action<GCBulkMovedObjectRanges> GCGCBulkMovedObjectRanges
        {
            add
            {
                source.RegisterEventTemplate(GCGCBulkMovedObjectRangesTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 22, ProviderGuid);
            }
        }
        public event Action<GCBulkNode> GCGCBulkNode
        {
            add
            {
                source.RegisterEventTemplate(GCGCBulkNodeTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 18, ProviderGuid);
            }
        }
        public event Action<GCBulkRCW> GCGCBulkRCW
        {
            add
            {
                source.RegisterEventTemplate(GCGCBulkRCWTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 37, ProviderGuid);
            }
        }
        public event Action<GCBulkRootCCW> GCGCBulkRootCCW
        {
            add
            {
                source.RegisterEventTemplate(GCGCBulkRootCCWTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 36, ProviderGuid);
            }
        }
        public event Action<GCBulkRootConditionalWeakTableElementEdge> GCGCBulkRootConditionalWeakTableElementEdge
        {
            add
            {
                source.RegisterEventTemplate(GCGCBulkRootConditionalWeakTableElementEdgeTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 17, ProviderGuid);
            }
        }
        public event Action<GCBulkRootEdge> GCGCBulkRootEdge
        {
            add
            {
                source.RegisterEventTemplate(GCGCBulkRootEdgeTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 16, ProviderGuid);
            }
        }
        public event Action<GCBulkRootStaticVar> GCGCBulkRootStaticVar
        {
            add
            {
                source.RegisterEventTemplate(GCGCBulkRootStaticVarTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 38, ProviderGuid);
            }
        }
        public event Action<GCBulkSurvivingObjectRanges> GCGCBulkSurvivingObjectRanges
        {
            add
            {
                source.RegisterEventTemplate(GCGCBulkSurvivingObjectRangesTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 21, ProviderGuid);
            }
        }
        public event Action<GCGenerationRange> GCGCGenerationRange
        {
            add
            {
                source.RegisterEventTemplate(GCGCGenerationRangeTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 23, ProviderGuid);
            }
        }
        public event Action<GCSampledObjectAllocation> GCGCSampledObjectAllocation
        {
            add
            {
                source.RegisterEventTemplate(GCGCSampledObjectAllocationTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 20, ProviderGuid);
            }
        }
        public event Action<GCSampledObjectAllocation> GCGCSampledObjectAllocation32
        {
            add
            {
                source.RegisterEventTemplate(GCGCSampledObjectAllocation32Template(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 32, ProviderGuid);
            }
        }
        public event Action<GCHeapStats> GCHeapStats
        {
            add
            {
                source.RegisterEventTemplate(GCHeapStatsTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 4, ProviderGuid);
            }
        }
        public event Action<IncreaseMemoryPressure> GCIncreaseMemoryPressure
        {
            add
            {
                source.RegisterEventTemplate(GCIncreaseMemoryPressureTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 200, ProviderGuid);
            }
        }
        public event Action<GCMark> GCMarkCards
        {
            add
            {
                source.RegisterEventTemplate(GCMarkCardsTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 28, ProviderGuid);
            }
        }
        public event Action<GCMark> GCMarkFinalizeQueueRoots
        {
            add
            {
                source.RegisterEventTemplate(GCMarkFinalizeQueueRootsTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 26, ProviderGuid);
            }
        }
        public event Action<GCMark> GCMarkHandles
        {
            add
            {
                source.RegisterEventTemplate(GCMarkHandlesTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 27, ProviderGuid);
            }
        }
        public event Action<GCMark> GCMarkStackRoots
        {
            add
            {
                source.RegisterEventTemplate(GCMarkStackRootsTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 25, ProviderGuid);
            }
        }
        public event Action<PinObjectAtGCTime> GCPinObjectAtGCTime
        {
            add
            {
                source.RegisterEventTemplate(GCPinObjectAtGCTimeTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 33, ProviderGuid);
            }
        }
        public event Action<EmptyTraceData> GCRestartEEStart
        {
            add
            {
                source.RegisterEventTemplate(GCRestartEEStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 7, ProviderGuid);
            }
        }
        public event Action<EmptyTraceData> GCRestartEEStop
        {
            add
            {
                source.RegisterEventTemplate(GCRestartEEStopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 3, ProviderGuid);
            }
        }
        public event Action<SetGCHandle> GCSetGCHandle
        {
            add
            {
                source.RegisterEventTemplate(GCSetGCHandleTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 30, ProviderGuid);
            }
        }
        public event Action<GCStart> GCStart
        {
            add
            {
                source.RegisterEventTemplate(GCStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 1, ProviderGuid);
            }
        }
        public event Action<GCEnd> GCStop
        {
            add
            {
                source.RegisterEventTemplate(GCStopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 2, ProviderGuid);
            }
        }
        public event Action<GCSuspendEE> GCSuspendEEStart
        {
            add
            {
                source.RegisterEventTemplate(GCSuspendEEStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 9, ProviderGuid);
            }
        }
        public event Action<EmptyTraceData> GCSuspendEEStop
        {
            add
            {
                source.RegisterEventTemplate(GCSuspendEEStopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 8, ProviderGuid);
            }
        }
        public event Action<EmptyTraceData> GCTerminateConcurrentThread
        {
            add
            {
                source.RegisterEventTemplate(GCTerminateConcurrentThreadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 12, ProviderGuid);
            }
        }
        public event Action<GCTriggered> GCTriggered
        {
            add
            {
                source.RegisterEventTemplate(GCTriggeredTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 35, ProviderGuid);
            }
        }
        public event Action<ILStubCacheHit> ILStubStubCacheHit
        {
            add
            {
                source.RegisterEventTemplate(ILStubStubCacheHitTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 89, ProviderGuid);
            }
        }
        public event Action<ILStubGenerated> ILStubStubGenerated
        {
            add
            {
                source.RegisterEventTemplate(ILStubStubGeneratedTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 88, ProviderGuid);
            }
        }
        public event Action<IOThread> IOThreadCreationStart
        {
            add
            {
                source.RegisterEventTemplate(IOThreadCreationStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 44, ProviderGuid);
            }
        }
        public event Action<IOThread> IOThreadCreationStop
        {
            add
            {
                source.RegisterEventTemplate(IOThreadCreationStopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 45, ProviderGuid);
            }
        }
        public event Action<IOThread> IOThreadRetirementStart
        {
            add
            {
                source.RegisterEventTemplate(IOThreadRetirementStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 46, ProviderGuid);
            }
        }
        public event Action<IOThread> IOThreadRetirementStop
        {
            add
            {
                source.RegisterEventTemplate(IOThreadRetirementStopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 47, ProviderGuid);
            }
        }
        public event Action<AppDomainLoadUnload> LoaderAppDomainLoad
        {
            add
            {
                source.RegisterEventTemplate(LoaderAppDomainLoadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 156, ProviderGuid);
            }
        }
        public event Action<AppDomainLoadUnload> LoaderAppDomainUnload
        {
            add
            {
                source.RegisterEventTemplate(LoaderAppDomainUnloadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 157, ProviderGuid);
            }
        }
        public event Action<AssemblyLoadUnload> LoaderAssemblyLoad
        {
            add
            {
                source.RegisterEventTemplate(LoaderAssemblyLoadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 154, ProviderGuid);
            }
        }
        public event Action<AssemblyLoadUnload> LoaderAssemblyUnload
        {
            add
            {
                source.RegisterEventTemplate(LoaderAssemblyUnloadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 155, ProviderGuid);
            }
        }
        public event Action<DomainModuleLoadUnload> LoaderDomainModuleLoad
        {
            add
            {
                source.RegisterEventTemplate(LoaderDomainModuleLoadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 151, ProviderGuid);
            }
        }
        public event Action<ModuleLoadUnload> LoaderModuleDCStartV2
        {
            add
            {
                source.RegisterEventTemplate(LoaderModuleDCStartV2Template(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 149, ProviderGuid);
            }
        }
        public event Action<ModuleLoadUnload> LoaderModuleDCStopV2
        {
            add
            {
                source.RegisterEventTemplate(LoaderModuleDCStopV2Template(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 150, ProviderGuid);
            }
        }
        public event Action<ModuleLoadUnload> LoaderModuleLoad
        {
            add
            {
                source.RegisterEventTemplate(LoaderModuleLoadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 152, ProviderGuid);
            }
        }
        public event Action<ModuleLoadUnload> LoaderModuleUnload
        {
            add
            {
                source.RegisterEventTemplate(LoaderModuleUnloadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 153, ProviderGuid);
            }
        }
        public event Action<EmptyTraceData> MethodDCEndCompleteV2
        {
            add
            {
                source.RegisterEventTemplate(MethodDCEndCompleteV2Template(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 136, ProviderGuid);
            }
        }
        public event Action<EmptyTraceData> MethodDCStartCompleteV2
        {
            add
            {
                source.RegisterEventTemplate(MethodDCStartCompleteV2Template(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 135, ProviderGuid);
            }
        }
        public event Action<MethodLoadUnload> MethodDCStartV2
        {
            add
            {
                source.RegisterEventTemplate(MethodDCStartV2Template(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 137, ProviderGuid);
            }
        }
        public event Action<MethodLoadUnloadVerbose> MethodDCStartVerboseV2
        {
            add
            {
                source.RegisterEventTemplate(MethodDCStartVerboseV2Template(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 139, ProviderGuid);
            }
        }
        public event Action<MethodLoadUnload> MethodDCStopV2
        {
            add
            {
                source.RegisterEventTemplate(MethodDCStopV2Template(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 138, ProviderGuid);
            }
        }
        public event Action<MethodLoadUnloadVerbose> MethodDCStopVerboseV2
        {
            add
            {
                source.RegisterEventTemplate(MethodDCStopVerboseV2Template(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 140, ProviderGuid);
            }
        }
        public event Action<MethodJitInliningFailed> MethodInliningFailed
        {
            add
            {
                source.RegisterEventTemplate(MethodInliningFailedTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 186, ProviderGuid);
            }
        }
        public event Action<MethodJitInliningSucceeded> MethodInliningSucceeded
        {
            add
            {
                source.RegisterEventTemplate(MethodInliningSucceededTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 185, ProviderGuid);
            }
        }
        public event Action<MethodJittingStarted> MethodJittingStarted
        {
            add
            {
                source.RegisterEventTemplate(MethodJittingStartedTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 145, ProviderGuid);
            }
        }
        public event Action<MethodLoadUnload> MethodLoad
        {
            add
            {
                source.RegisterEventTemplate(MethodLoadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 141, ProviderGuid);
            }
        }
        public event Action<MethodLoadUnloadVerbose> MethodLoadVerbose
        {
            add
            {
                source.RegisterEventTemplate(MethodLoadVerboseTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 143, ProviderGuid);
            }
        }
        public event Action<MethodILToNativeMap> MethodMethodILToNativeMap
        {
            add
            {
                source.RegisterEventTemplate(MethodMethodILToNativeMapTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 190, ProviderGuid);
            }
        }
        public event Action<MethodJitTailCallFailed> MethodTailCallFailed
        {
            add
            {
                source.RegisterEventTemplate(MethodTailCallFailedTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 189, ProviderGuid);
            }
        }
        public event Action<MethodJitTailCallSucceeded> MethodTailCallSucceeded
        {
            add
            {
                source.RegisterEventTemplate(MethodTailCallSucceededTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 188, ProviderGuid);
            }
        }
        public event Action<MethodLoadUnload> MethodUnload
        {
            add
            {
                source.RegisterEventTemplate(MethodUnloadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 142, ProviderGuid);
            }
        }
        public event Action<MethodLoadUnloadVerbose> MethodUnloadVerbose
        {
            add
            {
                source.RegisterEventTemplate(MethodUnloadVerboseTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 144, ProviderGuid);
            }
        }
        public event Action<RuntimeInformation> RuntimeStart
        {
            add
            {
                source.RegisterEventTemplate(RuntimeStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 187, ProviderGuid);
            }
        }
        public event Action<StrongNameVerification> StrongNameVerificationStart
        {
            add
            {
                source.RegisterEventTemplate(StrongNameVerificationStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 181, ProviderGuid);
            }
        }
        public event Action<StrongNameVerification> StrongNameVerificationStop
        {
            add
            {
                source.RegisterEventTemplate(StrongNameVerificationStopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 182, ProviderGuid);
            }
        }
        public event Action<ThreadStartWork> ThreadCreating
        {
            add
            {
                source.RegisterEventTemplate(ThreadCreatingTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 70, ProviderGuid);
            }
        }
        public event Action<ThreadPoolWork> ThreadPoolDequeue
        {
            add
            {
                source.RegisterEventTemplate(ThreadPoolDequeueTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 62, ProviderGuid);
            }
        }
        public event Action<ThreadPoolWork> ThreadPoolEnqueue
        {
            add
            {
                source.RegisterEventTemplate(ThreadPoolEnqueueTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 61, ProviderGuid);
            }
        }
        public event Action<ThreadPoolIOWork> ThreadPoolIODequeue
        {
            add
            {
                source.RegisterEventTemplate(ThreadPoolIODequeueTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 64, ProviderGuid);
            }
        }
        public event Action<ThreadPoolIOWorkEnqueue> ThreadPoolIOEnqueue
        {
            add
            {
                source.RegisterEventTemplate(ThreadPoolIOEnqueueTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 63, ProviderGuid);
            }
        }
        public event Action<ThreadPoolIOWork> ThreadPoolIOPack
        {
            add
            {
                source.RegisterEventTemplate(ThreadPoolIOPackTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 65, ProviderGuid);
            }
        }
        public event Action<ClrThreadPoolSuspend> ThreadpoolSuspensionV2Start
        {
            add
            {
                source.RegisterEventTemplate(ThreadpoolSuspensionV2StartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 48, ProviderGuid);
            }
        }
        public event Action<ClrThreadPoolSuspend> ThreadpoolSuspensionV2Stop
        {
            add
            {
                source.RegisterEventTemplate(ThreadpoolSuspensionV2StopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 49, ProviderGuid);
            }
        }
        public event Action<ThreadPoolWorkerThreadAdjustmentAdjustment> ThreadPoolWorkerThreadAdjustment
        {
            add
            {
                source.RegisterEventTemplate(ThreadPoolWorkerThreadAdjustmentTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 55, ProviderGuid);
            }
        }
        public event Action<ThreadPoolWorkerThreadAdjustmentSample> ThreadPoolWorkerThreadAdjustmentSample
        {
            add
            {
                source.RegisterEventTemplate(ThreadPoolWorkerThreadAdjustmentSampleTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 54, ProviderGuid);
            }
        }
        public event Action<ThreadPoolWorkerThreadAdjustmentStats> ThreadPoolWorkerThreadAdjustmentStats
        {
            add
            {
                source.RegisterEventTemplate(ThreadPoolWorkerThreadAdjustmentStatsTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 56, ProviderGuid);
            }
        }
        public event Action<ThreadPoolWorkerThread> ThreadPoolWorkerThreadRetirementStart
        {
            add
            {
                source.RegisterEventTemplate(ThreadPoolWorkerThreadRetirementStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 52, ProviderGuid);
            }
        }
        public event Action<ThreadPoolWorkerThread> ThreadPoolWorkerThreadRetirementStop
        {
            add
            {
                source.RegisterEventTemplate(ThreadPoolWorkerThreadRetirementStopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 53, ProviderGuid);
            }
        }
        public event Action<ThreadPoolWorkerThread> ThreadPoolWorkerThreadStart
        {
            add
            {
                source.RegisterEventTemplate(ThreadPoolWorkerThreadStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 50, ProviderGuid);
            }
        }
        public event Action<ThreadPoolWorkerThread> ThreadPoolWorkerThreadStop
        {
            add
            {
                source.RegisterEventTemplate(ThreadPoolWorkerThreadStopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 51, ProviderGuid);
            }
        }
        public event Action<ThreadPoolWorkerThread> ThreadPoolWorkerThreadWait
        {
            add
            {
                source.RegisterEventTemplate(ThreadPoolWorkerThreadWaitTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 57, ProviderGuid);
            }
        }
        public event Action<ThreadPoolWorkingThreadCount> ThreadPoolWorkingThreadCountStart
        {
            add
            {
                source.RegisterEventTemplate(ThreadPoolWorkingThreadCountStartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 60, ProviderGuid);
            }
        }
        public event Action<ThreadStartWork> ThreadRunning
        {
            add
            {
                source.RegisterEventTemplate(ThreadRunningTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 71, ProviderGuid);
            }
        }
        public event Action<BulkType> TypeBulkType
        {
            add
            {
                source.RegisterEventTemplate(TypeBulkTypeTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 15, ProviderGuid);
            }
        }
        public event Action<ClrWorkerThread> WorkerThreadCreationV2Start
        {
            add
            {
                source.RegisterEventTemplate(WorkerThreadCreationV2StartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 40, ProviderGuid);
            }
        }
        public event Action<ClrWorkerThread> WorkerThreadCreationV2Stop
        {
            add
            {
                source.RegisterEventTemplate(WorkerThreadCreationV2StopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 41, ProviderGuid);
            }
        }
        public event Action<ClrWorkerThread> WorkerThreadRetirementV2Start
        {
            add
            {
                source.RegisterEventTemplate(WorkerThreadRetirementV2StartTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 42, ProviderGuid);
            }
        }
        public event Action<ClrWorkerThread> WorkerThreadRetirementV2Stop
        {
            add
            {
                source.RegisterEventTemplate(WorkerThreadRetirementV2StopTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 43, ProviderGuid);
            }
        }

        #region private
        protected override string GetProviderName() { return ProviderName; }

        static private ThreadTerminatedOrTransition AppDomainResourceManagementDomainEnterTemplate(Action<ThreadTerminatedOrTransition> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadTerminatedOrTransition(action, 87, 14, "AppDomainResourceManagement", Guid.Empty, 52, "DomainEnter", ProviderGuid, ProviderName );
        }
        static private AppDomainMemAllocated AppDomainResourceManagementMemAllocatedTemplate(Action<AppDomainMemAllocated> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new AppDomainMemAllocated(action, 83, 14, "AppDomainResourceManagement", Guid.Empty, 48, "MemAllocated", ProviderGuid, ProviderName );
        }
        static private AppDomainMemSurvived AppDomainResourceManagementMemSurvivedTemplate(Action<AppDomainMemSurvived> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new AppDomainMemSurvived(action, 84, 14, "AppDomainResourceManagement", Guid.Empty, 49, "MemSurvived", ProviderGuid, ProviderName );
        }
        static private ThreadCreated AppDomainResourceManagementThreadCreatedTemplate(Action<ThreadCreated> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadCreated(action, 85, 14, "AppDomainResourceManagement", Guid.Empty, 50, "ThreadCreated", ProviderGuid, ProviderName );
        }
        static private ThreadTerminatedOrTransition AppDomainResourceManagementThreadTerminatedTemplate(Action<ThreadTerminatedOrTransition> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadTerminatedOrTransition(action, 86, 14, "AppDomainResourceManagement", Guid.Empty, 51, "ThreadTerminated", ProviderGuid, ProviderName );
        }
        static private AuthenticodeVerification AuthenticodeVerificationStartTemplate(Action<AuthenticodeVerification> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new AuthenticodeVerification(action, 183, 13, "AuthenticodeVerification", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private AuthenticodeVerification AuthenticodeVerificationStopTemplate(Action<AuthenticodeVerification> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new AuthenticodeVerification(action, 184, 13, "AuthenticodeVerification", Guid.Empty, 2, "Stop", ProviderGuid, ProviderName );
        }
        static private ModuleRange ClrPerfTrackModuleRangeLoadTemplate(Action<ModuleRange> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ModuleRange(action, 158, 20, "ClrPerfTrack", Guid.Empty, 10, "ModuleRangeLoad", ProviderGuid, ProviderName );
        }
        static private ClrStackWalk ClrStackWalkTemplate(Action<ClrStackWalk> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ClrStackWalk(action, 82, 11, "ClrStack", Guid.Empty, 82, "Walk", ProviderGuid, ProviderName );
        }
        static private EmptyTraceData ContentionStartTemplate(Action<EmptyTraceData> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new EmptyTraceData(action, 81, 8, "Contention", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private Contention ContentionStopTemplate(Action<Contention> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new Contention(action, 91, 8, "Contention", Guid.Empty, 2, "Stop", ProviderGuid, ProviderName );
        }
        static private EmptyTraceData DebugExceptionProcessingStartTemplate(Action<EmptyTraceData> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new EmptyTraceData(action, 242, 26, "DebugExceptionProcessing", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private EmptyTraceData DebugExceptionProcessingStopTemplate(Action<EmptyTraceData> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new EmptyTraceData(action, 243, 26, "DebugExceptionProcessing", Guid.Empty, 2, "Stop", ProviderGuid, ProviderName );
        }
        static private EmptyTraceData DebugIPCEventStartTemplate(Action<EmptyTraceData> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new EmptyTraceData(action, 240, 25, "DebugIPCEvent", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private EmptyTraceData DebugIPCEventStopTemplate(Action<EmptyTraceData> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new EmptyTraceData(action, 241, 25, "DebugIPCEvent", Guid.Empty, 2, "Stop", ProviderGuid, ProviderName );
        }
        static private EmptyTraceData ExceptionStartTemplate(Action<EmptyTraceData> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new EmptyTraceData(action, 80, 7, "Exception", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private GCAllocationTick GCAllocationTickTemplate(Action<GCAllocationTick> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCAllocationTick(action, 10, 1, "GC", Guid.Empty, 11, "AllocationTick", ProviderGuid, ProviderName );
        }
        static private EmptyTraceData GCCreateConcurrentThreadTemplate(Action<EmptyTraceData> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new EmptyTraceData(action, 11, 1, "GC", Guid.Empty, 12, "CreateConcurrentThread", ProviderGuid, ProviderName );
        }
        static private GCCreateSegment GCCreateSegmentTemplate(Action<GCCreateSegment> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCCreateSegment(action, 5, 1, "GC", Guid.Empty, 134, "CreateSegment", ProviderGuid, ProviderName );
        }
        static private DecreaseMemoryPressure GCDecreaseMemoryPressureTemplate(Action<DecreaseMemoryPressure> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new DecreaseMemoryPressure(action, 201, 1, "GC", Guid.Empty, 201, "DecreaseMemoryPressure", ProviderGuid, ProviderName );
        }
        static private DestroyGCHandle GCDestoryGCHandleTemplate(Action<DestroyGCHandle> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new DestroyGCHandle(action, 31, 1, "GC", Guid.Empty, 34, "DestoryGCHandle", ProviderGuid, ProviderName );
        }
        static private FinalizeObject GCFinalizeObjectTemplate(Action<FinalizeObject> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new FinalizeObject(action, 29, 1, "GC", Guid.Empty, 32, "FinalizeObject", ProviderGuid, ProviderName );
        }
        static private EmptyTraceData GCFinalizersStartTemplate(Action<EmptyTraceData> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new EmptyTraceData(action, 14, 1, "GC", Guid.Empty, 19, "FinalizersStart", ProviderGuid, ProviderName );
        }
        static private GCFinalizersEnd GCFinalizersStopTemplate(Action<GCFinalizersEnd> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCFinalizersEnd(action, 13, 1, "GC", Guid.Empty, 15, "FinalizersStop", ProviderGuid, ProviderName );
        }
        static private GCFreeSegment GCFreeSegmentTemplate(Action<GCFreeSegment> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCFreeSegment(action, 6, 1, "GC", Guid.Empty, 135, "FreeSegment", ProviderGuid, ProviderName );
        }
        static private GCBulkEdge GCGCBulkEdgeTemplate(Action<GCBulkEdge> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCBulkEdge(action, 19, 1, "GC", Guid.Empty, 23, "GCBulkEdge", ProviderGuid, ProviderName );
        }
        static private GCBulkMovedObjectRanges GCGCBulkMovedObjectRangesTemplate(Action<GCBulkMovedObjectRanges> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCBulkMovedObjectRanges(action, 22, 1, "GC", Guid.Empty, 26, "GCBulkMovedObjectRanges", ProviderGuid, ProviderName );
        }
        static private GCBulkNode GCGCBulkNodeTemplate(Action<GCBulkNode> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCBulkNode(action, 18, 1, "GC", Guid.Empty, 22, "GCBulkNode", ProviderGuid, ProviderName );
        }
        static private GCBulkRCW GCGCBulkRCWTemplate(Action<GCBulkRCW> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCBulkRCW(action, 37, 1, "GC", Guid.Empty, 39, "GCBulkRCW", ProviderGuid, ProviderName );
        }
        static private GCBulkRootCCW GCGCBulkRootCCWTemplate(Action<GCBulkRootCCW> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCBulkRootCCW(action, 36, 1, "GC", Guid.Empty, 38, "GCBulkRootCCW", ProviderGuid, ProviderName );
        }
        static private GCBulkRootConditionalWeakTableElementEdge GCGCBulkRootConditionalWeakTableElementEdgeTemplate(Action<GCBulkRootConditionalWeakTableElementEdge> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCBulkRootConditionalWeakTableElementEdge(action, 17, 1, "GC", Guid.Empty, 21, "GCBulkRootConditionalWeakTableElementEdge", ProviderGuid, ProviderName );
        }
        static private GCBulkRootEdge GCGCBulkRootEdgeTemplate(Action<GCBulkRootEdge> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCBulkRootEdge(action, 16, 1, "GC", Guid.Empty, 20, "GCBulkRootEdge", ProviderGuid, ProviderName );
        }
        static private GCBulkRootStaticVar GCGCBulkRootStaticVarTemplate(Action<GCBulkRootStaticVar> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCBulkRootStaticVar(action, 38, 1, "GC", Guid.Empty, 40, "GCBulkRootStaticVar", ProviderGuid, ProviderName );
        }
        static private GCBulkSurvivingObjectRanges GCGCBulkSurvivingObjectRangesTemplate(Action<GCBulkSurvivingObjectRanges> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCBulkSurvivingObjectRanges(action, 21, 1, "GC", Guid.Empty, 25, "GCBulkSurvivingObjectRanges", ProviderGuid, ProviderName );
        }
        static private GCGenerationRange GCGCGenerationRangeTemplate(Action<GCGenerationRange> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCGenerationRange(action, 23, 1, "GC", Guid.Empty, 27, "GCGenerationRange", ProviderGuid, ProviderName );
        }
        static private GCSampledObjectAllocation GCGCSampledObjectAllocationTemplate(Action<GCSampledObjectAllocation> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCSampledObjectAllocation(action, 20, 1, "GC", Guid.Empty, 24, "GCSampledObjectAllocation", ProviderGuid, ProviderName );
        }
        static private GCSampledObjectAllocation GCGCSampledObjectAllocation32Template(Action<GCSampledObjectAllocation> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCSampledObjectAllocation(action, 32, 1, "GC", Guid.Empty, 24, "GCSampledObjectAllocation", ProviderGuid, ProviderName );
        }
        static private GCHeapStats GCHeapStatsTemplate(Action<GCHeapStats> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCHeapStats(action, 4, 1, "GC", Guid.Empty, 133, "HeapStats", ProviderGuid, ProviderName );
        }
        static private IncreaseMemoryPressure GCIncreaseMemoryPressureTemplate(Action<IncreaseMemoryPressure> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new IncreaseMemoryPressure(action, 200, 1, "GC", Guid.Empty, 200, "IncreaseMemoryPressure", ProviderGuid, ProviderName );
        }
        static private GCMark GCMarkCardsTemplate(Action<GCMark> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCMark(action, 28, 1, "GC", Guid.Empty, 31, "MarkCards", ProviderGuid, ProviderName );
        }
        static private GCMark GCMarkFinalizeQueueRootsTemplate(Action<GCMark> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCMark(action, 26, 1, "GC", Guid.Empty, 29, "MarkFinalizeQueueRoots", ProviderGuid, ProviderName );
        }
        static private GCMark GCMarkHandlesTemplate(Action<GCMark> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCMark(action, 27, 1, "GC", Guid.Empty, 30, "MarkHandles", ProviderGuid, ProviderName );
        }
        static private GCMark GCMarkStackRootsTemplate(Action<GCMark> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCMark(action, 25, 1, "GC", Guid.Empty, 28, "MarkStackRoots", ProviderGuid, ProviderName );
        }
        static private PinObjectAtGCTime GCPinObjectAtGCTimeTemplate(Action<PinObjectAtGCTime> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new PinObjectAtGCTime(action, 33, 1, "GC", Guid.Empty, 36, "PinObjectAtGCTime", ProviderGuid, ProviderName );
        }
        static private EmptyTraceData GCRestartEEStartTemplate(Action<EmptyTraceData> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new EmptyTraceData(action, 7, 1, "GC", Guid.Empty, 136, "RestartEEStart", ProviderGuid, ProviderName );
        }
        static private EmptyTraceData GCRestartEEStopTemplate(Action<EmptyTraceData> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new EmptyTraceData(action, 3, 1, "GC", Guid.Empty, 132, "RestartEEStop", ProviderGuid, ProviderName );
        }
        static private SetGCHandle GCSetGCHandleTemplate(Action<SetGCHandle> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new SetGCHandle(action, 30, 1, "GC", Guid.Empty, 33, "SetGCHandle", ProviderGuid, ProviderName );
        }
        static private GCStart GCStartTemplate(Action<GCStart> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCStart(action, 1, 1, "GC", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private GCEnd GCStopTemplate(Action<GCEnd> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCEnd(action, 2, 1, "GC", Guid.Empty, 2, "Stop", ProviderGuid, ProviderName );
        }
        static private GCSuspendEE GCSuspendEEStartTemplate(Action<GCSuspendEE> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCSuspendEE(action, 9, 1, "GC", Guid.Empty, 10, "SuspendEEStart", ProviderGuid, ProviderName );
        }
        static private EmptyTraceData GCSuspendEEStopTemplate(Action<EmptyTraceData> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new EmptyTraceData(action, 8, 1, "GC", Guid.Empty, 137, "SuspendEEStop", ProviderGuid, ProviderName );
        }
        static private EmptyTraceData GCTerminateConcurrentThreadTemplate(Action<EmptyTraceData> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new EmptyTraceData(action, 12, 1, "GC", Guid.Empty, 13, "TerminateConcurrentThread", ProviderGuid, ProviderName );
        }
        static private GCTriggered GCTriggeredTemplate(Action<GCTriggered> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new GCTriggered(action, 35, 1, "GC", Guid.Empty, 35, "Triggered", ProviderGuid, ProviderName );
        }
        static private ILStubCacheHit ILStubStubCacheHitTemplate(Action<ILStubCacheHit> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ILStubCacheHit(action, 89, 15, "ILStub", Guid.Empty, 89, "StubCacheHit", ProviderGuid, ProviderName );
        }
        static private ILStubGenerated ILStubStubGeneratedTemplate(Action<ILStubGenerated> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ILStubGenerated(action, 88, 15, "ILStub", Guid.Empty, 88, "StubGenerated", ProviderGuid, ProviderName );
        }
        static private IOThread IOThreadCreationStartTemplate(Action<IOThread> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new IOThread(action, 44, 3, "IOThreadCreation", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private IOThread IOThreadCreationStopTemplate(Action<IOThread> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new IOThread(action, 45, 3, "IOThreadCreation", Guid.Empty, 2, "Stop", ProviderGuid, ProviderName );
        }
        static private IOThread IOThreadRetirementStartTemplate(Action<IOThread> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new IOThread(action, 46, 5, "IOThreadRetirement", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private IOThread IOThreadRetirementStopTemplate(Action<IOThread> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new IOThread(action, 47, 5, "IOThreadRetirement", Guid.Empty, 2, "Stop", ProviderGuid, ProviderName );
        }
        static private AppDomainLoadUnload LoaderAppDomainLoadTemplate(Action<AppDomainLoadUnload> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new AppDomainLoadUnload(action, 156, 10, "Loader", Guid.Empty, 41, "AppDomainLoad", ProviderGuid, ProviderName );
        }
        static private AppDomainLoadUnload LoaderAppDomainUnloadTemplate(Action<AppDomainLoadUnload> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new AppDomainLoadUnload(action, 157, 10, "Loader", Guid.Empty, 42, "AppDomainUnload", ProviderGuid, ProviderName );
        }
        static private AssemblyLoadUnload LoaderAssemblyLoadTemplate(Action<AssemblyLoadUnload> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new AssemblyLoadUnload(action, 154, 10, "Loader", Guid.Empty, 37, "AssemblyLoad", ProviderGuid, ProviderName );
        }
        static private AssemblyLoadUnload LoaderAssemblyUnloadTemplate(Action<AssemblyLoadUnload> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new AssemblyLoadUnload(action, 155, 10, "Loader", Guid.Empty, 38, "AssemblyUnload", ProviderGuid, ProviderName );
        }
        static private DomainModuleLoadUnload LoaderDomainModuleLoadTemplate(Action<DomainModuleLoadUnload> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new DomainModuleLoadUnload(action, 151, 10, "Loader", Guid.Empty, 45, "DomainModuleLoad", ProviderGuid, ProviderName );
        }
        static private ModuleLoadUnload LoaderModuleDCStartV2Template(Action<ModuleLoadUnload> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ModuleLoadUnload(action, 149, 10, "Loader", Guid.Empty, 35, "ModuleDCStartV2", ProviderGuid, ProviderName );
        }
        static private ModuleLoadUnload LoaderModuleDCStopV2Template(Action<ModuleLoadUnload> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ModuleLoadUnload(action, 150, 10, "Loader", Guid.Empty, 36, "ModuleDCStopV2", ProviderGuid, ProviderName );
        }
        static private ModuleLoadUnload LoaderModuleLoadTemplate(Action<ModuleLoadUnload> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ModuleLoadUnload(action, 152, 10, "Loader", Guid.Empty, 33, "ModuleLoad", ProviderGuid, ProviderName );
        }
        static private ModuleLoadUnload LoaderModuleUnloadTemplate(Action<ModuleLoadUnload> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ModuleLoadUnload(action, 153, 10, "Loader", Guid.Empty, 34, "ModuleUnload", ProviderGuid, ProviderName );
        }
        static private EmptyTraceData MethodDCEndCompleteV2Template(Action<EmptyTraceData> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new EmptyTraceData(action, 136, 9, "Method", Guid.Empty, 15, "DCEndCompleteV2", ProviderGuid, ProviderName );
        }
        static private EmptyTraceData MethodDCStartCompleteV2Template(Action<EmptyTraceData> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new EmptyTraceData(action, 135, 9, "Method", Guid.Empty, 14, "DCStartCompleteV2", ProviderGuid, ProviderName );
        }
        static private MethodLoadUnload MethodDCStartV2Template(Action<MethodLoadUnload> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new MethodLoadUnload(action, 137, 9, "Method", Guid.Empty, 35, "DCStartV2", ProviderGuid, ProviderName );
        }
        static private MethodLoadUnloadVerbose MethodDCStartVerboseV2Template(Action<MethodLoadUnloadVerbose> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new MethodLoadUnloadVerbose(action, 139, 9, "Method", Guid.Empty, 39, "DCStartVerboseV2", ProviderGuid, ProviderName );
        }
        static private MethodLoadUnload MethodDCStopV2Template(Action<MethodLoadUnload> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new MethodLoadUnload(action, 138, 9, "Method", Guid.Empty, 36, "DCStopV2", ProviderGuid, ProviderName );
        }
        static private MethodLoadUnloadVerbose MethodDCStopVerboseV2Template(Action<MethodLoadUnloadVerbose> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new MethodLoadUnloadVerbose(action, 140, 9, "Method", Guid.Empty, 40, "DCStopVerboseV2", ProviderGuid, ProviderName );
        }
        static private MethodJitInliningFailed MethodInliningFailedTemplate(Action<MethodJitInliningFailed> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new MethodJitInliningFailed(action, 186, 9, "Method", Guid.Empty, 84, "InliningFailed", ProviderGuid, ProviderName );
        }
        static private MethodJitInliningSucceeded MethodInliningSucceededTemplate(Action<MethodJitInliningSucceeded> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new MethodJitInliningSucceeded(action, 185, 9, "Method", Guid.Empty, 83, "InliningSucceeded", ProviderGuid, ProviderName );
        }
        static private MethodJittingStarted MethodJittingStartedTemplate(Action<MethodJittingStarted> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new MethodJittingStarted(action, 145, 9, "Method", Guid.Empty, 42, "JittingStarted", ProviderGuid, ProviderName );
        }
        static private MethodLoadUnload MethodLoadTemplate(Action<MethodLoadUnload> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new MethodLoadUnload(action, 141, 9, "Method", Guid.Empty, 33, "Load", ProviderGuid, ProviderName );
        }
        static private MethodLoadUnloadVerbose MethodLoadVerboseTemplate(Action<MethodLoadUnloadVerbose> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new MethodLoadUnloadVerbose(action, 143, 9, "Method", Guid.Empty, 37, "LoadVerbose", ProviderGuid, ProviderName );
        }
        static private MethodILToNativeMap MethodMethodILToNativeMapTemplate(Action<MethodILToNativeMap> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new MethodILToNativeMap(action, 190, 9, "Method", Guid.Empty, 87, "MethodILToNativeMap", ProviderGuid, ProviderName );
        }
        static private MethodJitTailCallFailed MethodTailCallFailedTemplate(Action<MethodJitTailCallFailed> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new MethodJitTailCallFailed(action, 189, 9, "Method", Guid.Empty, 86, "TailCallFailed", ProviderGuid, ProviderName );
        }
        static private MethodJitTailCallSucceeded MethodTailCallSucceededTemplate(Action<MethodJitTailCallSucceeded> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new MethodJitTailCallSucceeded(action, 188, 9, "Method", Guid.Empty, 85, "TailCallSucceeded", ProviderGuid, ProviderName );
        }
        static private MethodLoadUnload MethodUnloadTemplate(Action<MethodLoadUnload> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new MethodLoadUnload(action, 142, 9, "Method", Guid.Empty, 34, "Unload", ProviderGuid, ProviderName );
        }
        static private MethodLoadUnloadVerbose MethodUnloadVerboseTemplate(Action<MethodLoadUnloadVerbose> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new MethodLoadUnloadVerbose(action, 144, 9, "Method", Guid.Empty, 38, "UnloadVerbose", ProviderGuid, ProviderName );
        }
        static private RuntimeInformation RuntimeStartTemplate(Action<RuntimeInformation> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new RuntimeInformation(action, 187, 19, "Runtime", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private StrongNameVerification StrongNameVerificationStartTemplate(Action<StrongNameVerification> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new StrongNameVerification(action, 181, 12, "StrongNameVerification", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private StrongNameVerification StrongNameVerificationStopTemplate(Action<StrongNameVerification> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new StrongNameVerification(action, 182, 12, "StrongNameVerification", Guid.Empty, 2, "Stop", ProviderGuid, ProviderName );
        }
        static private ThreadStartWork ThreadCreatingTemplate(Action<ThreadStartWork> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadStartWork(action, 70, 24, "Thread", Guid.Empty, 11, "Creating", ProviderGuid, ProviderName );
        }
        static private ThreadPoolWork ThreadPoolDequeueTemplate(Action<ThreadPoolWork> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadPoolWork(action, 62, 23, "ThreadPool", Guid.Empty, 12, "Dequeue", ProviderGuid, ProviderName );
        }
        static private ThreadPoolWork ThreadPoolEnqueueTemplate(Action<ThreadPoolWork> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadPoolWork(action, 61, 23, "ThreadPool", Guid.Empty, 11, "Enqueue", ProviderGuid, ProviderName );
        }
        static private ThreadPoolIOWork ThreadPoolIODequeueTemplate(Action<ThreadPoolIOWork> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadPoolIOWork(action, 64, 23, "ThreadPool", Guid.Empty, 14, "IODequeue", ProviderGuid, ProviderName );
        }
        static private ThreadPoolIOWorkEnqueue ThreadPoolIOEnqueueTemplate(Action<ThreadPoolIOWorkEnqueue> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadPoolIOWorkEnqueue(action, 63, 23, "ThreadPool", Guid.Empty, 13, "IOEnqueue", ProviderGuid, ProviderName );
        }
        static private ThreadPoolIOWork ThreadPoolIOPackTemplate(Action<ThreadPoolIOWork> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadPoolIOWork(action, 65, 23, "ThreadPool", Guid.Empty, 15, "IOPack", ProviderGuid, ProviderName );
        }
        static private ClrThreadPoolSuspend ThreadpoolSuspensionV2StartTemplate(Action<ClrThreadPoolSuspend> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ClrThreadPoolSuspend(action, 48, 6, "ThreadpoolSuspensionV2", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private ClrThreadPoolSuspend ThreadpoolSuspensionV2StopTemplate(Action<ClrThreadPoolSuspend> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ClrThreadPoolSuspend(action, 49, 6, "ThreadpoolSuspensionV2", Guid.Empty, 2, "Stop", ProviderGuid, ProviderName );
        }
        static private ThreadPoolWorkerThreadAdjustmentAdjustment ThreadPoolWorkerThreadAdjustmentTemplate(Action<ThreadPoolWorkerThreadAdjustmentAdjustment> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadPoolWorkerThreadAdjustmentAdjustment(action, 55, 18, "ThreadPoolWorkerThreadAdjustment", Guid.Empty, 101, "Adjustment", ProviderGuid, ProviderName );
        }
        static private ThreadPoolWorkerThreadAdjustmentSample ThreadPoolWorkerThreadAdjustmentSampleTemplate(Action<ThreadPoolWorkerThreadAdjustmentSample> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadPoolWorkerThreadAdjustmentSample(action, 54, 18, "ThreadPoolWorkerThreadAdjustment", Guid.Empty, 100, "Sample", ProviderGuid, ProviderName );
        }
        static private ThreadPoolWorkerThreadAdjustmentStats ThreadPoolWorkerThreadAdjustmentStatsTemplate(Action<ThreadPoolWorkerThreadAdjustmentStats> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadPoolWorkerThreadAdjustmentStats(action, 56, 18, "ThreadPoolWorkerThreadAdjustment", Guid.Empty, 102, "Stats", ProviderGuid, ProviderName );
        }
        static private ThreadPoolWorkerThread ThreadPoolWorkerThreadRetirementStartTemplate(Action<ThreadPoolWorkerThread> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadPoolWorkerThread(action, 52, 17, "ThreadPoolWorkerThreadRetirement", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private ThreadPoolWorkerThread ThreadPoolWorkerThreadRetirementStopTemplate(Action<ThreadPoolWorkerThread> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadPoolWorkerThread(action, 53, 17, "ThreadPoolWorkerThreadRetirement", Guid.Empty, 2, "Stop", ProviderGuid, ProviderName );
        }
        static private ThreadPoolWorkerThread ThreadPoolWorkerThreadStartTemplate(Action<ThreadPoolWorkerThread> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadPoolWorkerThread(action, 50, 16, "ThreadPoolWorkerThread", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private ThreadPoolWorkerThread ThreadPoolWorkerThreadStopTemplate(Action<ThreadPoolWorkerThread> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadPoolWorkerThread(action, 51, 16, "ThreadPoolWorkerThread", Guid.Empty, 2, "Stop", ProviderGuid, ProviderName );
        }
        static private ThreadPoolWorkerThread ThreadPoolWorkerThreadWaitTemplate(Action<ThreadPoolWorkerThread> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadPoolWorkerThread(action, 57, 16, "ThreadPoolWorkerThread", Guid.Empty, 90, "Wait", ProviderGuid, ProviderName );
        }
        static private ThreadPoolWorkingThreadCount ThreadPoolWorkingThreadCountStartTemplate(Action<ThreadPoolWorkingThreadCount> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadPoolWorkingThreadCount(action, 60, 22, "ThreadPoolWorkingThreadCount", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private ThreadStartWork ThreadRunningTemplate(Action<ThreadStartWork> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ThreadStartWork(action, 71, 24, "Thread", Guid.Empty, 12, "Running", ProviderGuid, ProviderName );
        }
        static private BulkType TypeBulkTypeTemplate(Action<BulkType> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new BulkType(action, 15, 21, "Type", Guid.Empty, 10, "BulkType", ProviderGuid, ProviderName );
        }
        static private ClrWorkerThread WorkerThreadCreationV2StartTemplate(Action<ClrWorkerThread> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ClrWorkerThread(action, 40, 2, "WorkerThreadCreationV2", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private ClrWorkerThread WorkerThreadCreationV2StopTemplate(Action<ClrWorkerThread> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ClrWorkerThread(action, 41, 2, "WorkerThreadCreationV2", Guid.Empty, 2, "Stop", ProviderGuid, ProviderName );
        }
        static private ClrWorkerThread WorkerThreadRetirementV2StartTemplate(Action<ClrWorkerThread> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ClrWorkerThread(action, 42, 4, "WorkerThreadRetirementV2", Guid.Empty, 1, "Start", ProviderGuid, ProviderName );
        }
        static private ClrWorkerThread WorkerThreadRetirementV2StopTemplate(Action<ClrWorkerThread> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new ClrWorkerThread(action, 43, 4, "WorkerThreadRetirementV2", Guid.Empty, 2, "Stop", ProviderGuid, ProviderName );
        }

        static private volatile TraceEvent[] s_templates;
        protected internal override void EnumerateTemplates(Func<string, string, EventFilterResponse> eventsToObserve, Action<TraceEvent> callback)
        {
            if (s_templates == null)
            {
                var templates = new TraceEvent[155];
                templates[0] = GCStartTemplate(null);
                templates[1] = GCStartTemplate(null);
                templates[2] = GCStartTemplate(null);
                templates[3] = GCStopTemplate(null);
                templates[4] = GCStopTemplate(null);
                templates[5] = GCRestartEEStopTemplate(null);
                templates[6] = GCRestartEEStopTemplate(null);
                templates[7] = GCHeapStatsTemplate(null);
                templates[8] = GCHeapStatsTemplate(null);
                templates[9] = GCCreateSegmentTemplate(null);
                templates[10] = GCCreateSegmentTemplate(null);
                templates[11] = GCFreeSegmentTemplate(null);
                templates[12] = GCFreeSegmentTemplate(null);
                templates[13] = GCRestartEEStartTemplate(null);
                templates[14] = GCRestartEEStartTemplate(null);
                templates[15] = GCSuspendEEStopTemplate(null);
                templates[16] = GCSuspendEEStopTemplate(null);
                templates[17] = GCSuspendEEStartTemplate(null);
                templates[18] = GCSuspendEEStartTemplate(null);
                templates[19] = GCAllocationTickTemplate(null);
                templates[20] = GCAllocationTickTemplate(null);
                templates[21] = GCAllocationTickTemplate(null);
                templates[22] = GCAllocationTickTemplate(null);
                templates[23] = GCCreateConcurrentThreadTemplate(null);
                templates[24] = GCCreateConcurrentThreadTemplate(null);
                templates[25] = GCTerminateConcurrentThreadTemplate(null);
                templates[26] = GCTerminateConcurrentThreadTemplate(null);
                templates[27] = GCFinalizersStopTemplate(null);
                templates[28] = GCFinalizersStopTemplate(null);
                templates[29] = GCFinalizersStartTemplate(null);
                templates[30] = GCFinalizersStartTemplate(null);
                templates[31] = TypeBulkTypeTemplate(null);
                templates[32] = GCGCBulkRootEdgeTemplate(null);
                templates[33] = GCGCBulkRootConditionalWeakTableElementEdgeTemplate(null);
                templates[34] = GCGCBulkNodeTemplate(null);
                templates[35] = GCGCBulkEdgeTemplate(null);
                templates[36] = GCGCSampledObjectAllocationTemplate(null);
                templates[37] = GCGCBulkSurvivingObjectRangesTemplate(null);
                templates[38] = GCGCBulkMovedObjectRangesTemplate(null);
                templates[39] = GCGCGenerationRangeTemplate(null);
                templates[40] = GCMarkStackRootsTemplate(null);
                templates[41] = GCMarkFinalizeQueueRootsTemplate(null);
                templates[42] = GCMarkHandlesTemplate(null);
                templates[43] = GCMarkCardsTemplate(null);
                templates[44] = GCFinalizeObjectTemplate(null);
                templates[45] = GCSetGCHandleTemplate(null);
                templates[46] = GCDestoryGCHandleTemplate(null);
                templates[47] = GCGCSampledObjectAllocationTemplate(null);
                templates[48] = GCPinObjectAtGCTimeTemplate(null);
                templates[49] = GCTriggeredTemplate(null);
                templates[50] = GCGCBulkRootCCWTemplate(null);
                templates[51] = GCGCBulkRCWTemplate(null);
                templates[52] = GCGCBulkRootStaticVarTemplate(null);
                templates[53] = WorkerThreadCreationV2StartTemplate(null);
                templates[54] = WorkerThreadCreationV2StopTemplate(null);
                templates[55] = WorkerThreadRetirementV2StartTemplate(null);
                templates[56] = WorkerThreadRetirementV2StopTemplate(null);
                templates[57] = IOThreadCreationStartTemplate(null);
                templates[58] = IOThreadCreationStartTemplate(null);
                templates[59] = IOThreadCreationStopTemplate(null);
                templates[60] = IOThreadCreationStopTemplate(null);
                templates[61] = IOThreadRetirementStartTemplate(null);
                templates[62] = IOThreadRetirementStartTemplate(null);
                templates[63] = IOThreadRetirementStopTemplate(null);
                templates[64] = IOThreadRetirementStopTemplate(null);
                templates[65] = ThreadpoolSuspensionV2StartTemplate(null);
                templates[66] = ThreadpoolSuspensionV2StopTemplate(null);
                templates[67] = ThreadPoolWorkerThreadStartTemplate(null);
                templates[68] = ThreadPoolWorkerThreadStopTemplate(null);
                templates[69] = ThreadPoolWorkerThreadRetirementStartTemplate(null);
                templates[70] = ThreadPoolWorkerThreadRetirementStopTemplate(null);
                templates[71] = ThreadPoolWorkerThreadAdjustmentSampleTemplate(null);
                templates[72] = ThreadPoolWorkerThreadAdjustmentTemplate(null);
                templates[73] = ThreadPoolWorkerThreadAdjustmentStatsTemplate(null);
                templates[74] = ThreadPoolWorkerThreadWaitTemplate(null);
                templates[75] = ThreadPoolWorkingThreadCountStartTemplate(null);
                templates[76] = ThreadPoolEnqueueTemplate(null);
                templates[77] = ThreadPoolDequeueTemplate(null);
                templates[78] = ThreadPoolIOEnqueueTemplate(null);
                templates[79] = ThreadPoolIODequeueTemplate(null);
                templates[80] = ThreadPoolIOPackTemplate(null);
                templates[81] = ThreadCreatingTemplate(null);
                templates[82] = ThreadRunningTemplate(null);
                templates[83] = ExceptionStartTemplate(null);
                templates[84] = ExceptionStartTemplate(null);
                templates[85] = ContentionStartTemplate(null);
                templates[86] = ContentionStartTemplate(null);
                templates[87] = ContentionStopTemplate(null);
                templates[88] = ClrStackWalkTemplate(null);
                templates[89] = AppDomainResourceManagementMemAllocatedTemplate(null);
                templates[90] = AppDomainResourceManagementMemSurvivedTemplate(null);
                templates[91] = AppDomainResourceManagementThreadCreatedTemplate(null);
                templates[92] = AppDomainResourceManagementThreadTerminatedTemplate(null);
                templates[93] = AppDomainResourceManagementDomainEnterTemplate(null);
                templates[94] = ILStubStubGeneratedTemplate(null);
                templates[95] = ILStubStubCacheHitTemplate(null);
                templates[96] = MethodDCStartCompleteV2Template(null);
                templates[97] = MethodDCEndCompleteV2Template(null);
                templates[98] = MethodDCStartV2Template(null);
                templates[99] = MethodDCStopV2Template(null);
                templates[100] = MethodDCStartVerboseV2Template(null);
                templates[101] = MethodDCStopVerboseV2Template(null);
                templates[102] = MethodLoadTemplate(null);
                templates[103] = MethodLoadTemplate(null);
                templates[104] = MethodLoadTemplate(null);
                templates[105] = MethodUnloadTemplate(null);
                templates[106] = MethodUnloadTemplate(null);
                templates[107] = MethodUnloadTemplate(null);
                templates[108] = MethodLoadVerboseTemplate(null);
                templates[109] = MethodLoadVerboseTemplate(null);
                templates[110] = MethodLoadVerboseTemplate(null);
                templates[111] = MethodUnloadVerboseTemplate(null);
                templates[112] = MethodUnloadVerboseTemplate(null);
                templates[113] = MethodUnloadVerboseTemplate(null);
                templates[114] = MethodJittingStartedTemplate(null);
                templates[115] = MethodJittingStartedTemplate(null);
                templates[116] = MethodInliningSucceededTemplate(null);
                templates[117] = MethodInliningFailedTemplate(null);
                templates[118] = MethodTailCallSucceededTemplate(null);
                templates[119] = MethodTailCallFailedTemplate(null);
                templates[120] = MethodMethodILToNativeMapTemplate(null);
                templates[121] = LoaderModuleDCStartV2Template(null);
                templates[122] = LoaderModuleDCStopV2Template(null);
                templates[123] = LoaderDomainModuleLoadTemplate(null);
                templates[124] = LoaderDomainModuleLoadTemplate(null);
                templates[125] = LoaderModuleLoadTemplate(null);
                templates[126] = LoaderModuleLoadTemplate(null);
                templates[127] = LoaderModuleLoadTemplate(null);
                templates[128] = LoaderModuleUnloadTemplate(null);
                templates[129] = LoaderModuleUnloadTemplate(null);
                templates[130] = LoaderModuleUnloadTemplate(null);
                templates[131] = LoaderAssemblyLoadTemplate(null);
                templates[132] = LoaderAssemblyLoadTemplate(null);
                templates[133] = LoaderAssemblyUnloadTemplate(null);
                templates[134] = LoaderAssemblyUnloadTemplate(null);
                templates[135] = LoaderAppDomainLoadTemplate(null);
                templates[136] = LoaderAppDomainLoadTemplate(null);
                templates[137] = LoaderAppDomainUnloadTemplate(null);
                templates[138] = LoaderAppDomainUnloadTemplate(null);
                templates[139] = ClrPerfTrackModuleRangeLoadTemplate(null);
                templates[140] = StrongNameVerificationStartTemplate(null);
                templates[141] = StrongNameVerificationStartTemplate(null);
                templates[142] = StrongNameVerificationStopTemplate(null);
                templates[143] = StrongNameVerificationStopTemplate(null);
                templates[144] = AuthenticodeVerificationStartTemplate(null);
                templates[145] = AuthenticodeVerificationStartTemplate(null);
                templates[146] = AuthenticodeVerificationStopTemplate(null);
                templates[147] = AuthenticodeVerificationStopTemplate(null);
                templates[148] = RuntimeStartTemplate(null);
                templates[149] = GCIncreaseMemoryPressureTemplate(null);
                templates[150] = GCDecreaseMemoryPressureTemplate(null);
                templates[151] = DebugIPCEventStartTemplate(null);
                templates[152] = DebugIPCEventStopTemplate(null);
                templates[153] = DebugExceptionProcessingStartTemplate(null);
                templates[154] = DebugExceptionProcessingStopTemplate(null);
                s_templates = templates;
            }
            foreach (var template in s_templates)
                if (eventsToObserve == null || eventsToObserve(template.ProviderName, template.EventName) == EventFilterResponse.AcceptEvent)
                    callback(template);
        }

        #endregion
    }
}

namespace Microsoft.Diagnostics.Tracing.Parsers.MicrosoftWindowsDotNETRuntime
{
    public sealed class ThreadTerminatedOrTransition : TraceEvent
    {
        public long ManagedThreadID { get { return GetInt64At(0); } }
        public long AppDomainID { get { return GetInt64At(8); } }
        public int ClrInstanceID { get { return GetInt16At(16); } }

        #region Private
        internal ThreadTerminatedOrTransition(Action<ThreadTerminatedOrTransition> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 18));
            Debug.Assert(!(Version > 0 && EventDataLength < 18));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ThreadTerminatedOrTransition>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ManagedThreadID", ManagedThreadID);
             XmlAttrib(sb, "AppDomainID", AppDomainID);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ManagedThreadID", "AppDomainID", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ManagedThreadID;
                case 1:
                    return AppDomainID;
                case 2:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ThreadTerminatedOrTransition> m_target;
        #endregion
    }
    public sealed class AppDomainMemAllocated : TraceEvent
    {
        public long AppDomainID { get { return GetInt64At(0); } }
        public long Allocated { get { return GetInt64At(8); } }
        public int ClrInstanceID { get { return GetInt16At(16); } }

        #region Private
        internal AppDomainMemAllocated(Action<AppDomainMemAllocated> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 18));
            Debug.Assert(!(Version > 0 && EventDataLength < 18));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<AppDomainMemAllocated>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "AppDomainID", AppDomainID);
             XmlAttrib(sb, "Allocated", Allocated);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "AppDomainID", "Allocated", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return AppDomainID;
                case 1:
                    return Allocated;
                case 2:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<AppDomainMemAllocated> m_target;
        #endregion
    }
    public sealed class AppDomainMemSurvived : TraceEvent
    {
        public long AppDomainID { get { return GetInt64At(0); } }
        public long Survived { get { return GetInt64At(8); } }
        public long ProcessSurvived { get { return GetInt64At(16); } }
        public int ClrInstanceID { get { return GetInt16At(24); } }

        #region Private
        internal AppDomainMemSurvived(Action<AppDomainMemSurvived> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 26));
            Debug.Assert(!(Version > 0 && EventDataLength < 26));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<AppDomainMemSurvived>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "AppDomainID", AppDomainID);
             XmlAttrib(sb, "Survived", Survived);
             XmlAttrib(sb, "ProcessSurvived", ProcessSurvived);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "AppDomainID", "Survived", "ProcessSurvived", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return AppDomainID;
                case 1:
                    return Survived;
                case 2:
                    return ProcessSurvived;
                case 3:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<AppDomainMemSurvived> m_target;
        #endregion
    }
    public sealed class ThreadCreated : TraceEvent
    {
        public long ManagedThreadID { get { return GetInt64At(0); } }
        public long AppDomainID { get { return GetInt64At(8); } }
        public ThreadFlags Flags { get { return (ThreadFlags)GetInt32At(16); } }
        public int ManagedThreadIndex { get { return GetInt32At(20); } }
        public int OSThreadID { get { return GetInt32At(24); } }
        public int ClrInstanceID { get { return GetInt16At(28); } }

        #region Private
        internal ThreadCreated(Action<ThreadCreated> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 30));
            Debug.Assert(!(Version > 0 && EventDataLength < 30));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ThreadCreated>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ManagedThreadID", ManagedThreadID);
             XmlAttrib(sb, "AppDomainID", AppDomainID);
             XmlAttrib(sb, "Flags", Flags);
             XmlAttrib(sb, "ManagedThreadIndex", ManagedThreadIndex);
             XmlAttrib(sb, "OSThreadID", OSThreadID);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ManagedThreadID", "AppDomainID", "Flags", "ManagedThreadIndex", "OSThreadID", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ManagedThreadID;
                case 1:
                    return AppDomainID;
                case 2:
                    return Flags;
                case 3:
                    return ManagedThreadIndex;
                case 4:
                    return OSThreadID;
                case 5:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ThreadCreated> m_target;
        #endregion
    }
    public sealed class AuthenticodeVerification : TraceEvent
    {
        public int VerificationFlags { get { return GetInt32At(0); } }
        public int ErrorCode { get { return GetInt32At(4); } }
        public string ModulePath { get { return GetUnicodeStringAt(8); } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(SkipUnicodeString(8)); return 0; } }

        #region Private
        internal AuthenticodeVerification(Action<AuthenticodeVerification> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(8)));
            Debug.Assert(!(Version == 1 && EventDataLength != SkipUnicodeString(8)+2));
            Debug.Assert(!(Version > 1 && EventDataLength < SkipUnicodeString(8)+2));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<AuthenticodeVerification>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "VerificationFlags", VerificationFlags);
             XmlAttrib(sb, "ErrorCode", ErrorCode);
             XmlAttrib(sb, "ModulePath", ModulePath);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "VerificationFlags", "ErrorCode", "ModulePath", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return VerificationFlags;
                case 1:
                    return ErrorCode;
                case 2:
                    return ModulePath;
                case 3:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<AuthenticodeVerification> m_target;
        #endregion
    }
    public sealed class ModuleRange : TraceEvent
    {
        public int ClrInstanceID { get { return GetInt16At(0); } }
        public long ModuleID { get { return GetInt64At(2); } }
        public int RangeBegin { get { return GetInt32At(10); } }
        public int RangeSize { get { return GetInt32At(14); } }
        public ModuleRangeType RangeType { get { return (ModuleRangeType)GetByteAt(18); } }

        #region Private
        internal ModuleRange(Action<ModuleRange> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 19));
            Debug.Assert(!(Version > 0 && EventDataLength < 19));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ModuleRange>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttrib(sb, "ModuleID", ModuleID);
             XmlAttrib(sb, "RangeBegin", RangeBegin);
             XmlAttrib(sb, "RangeSize", RangeSize);
             XmlAttrib(sb, "RangeType", RangeType);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ClrInstanceID", "ModuleID", "RangeBegin", "RangeSize", "RangeType"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ClrInstanceID;
                case 1:
                    return ModuleID;
                case 2:
                    return RangeBegin;
                case 3:
                    return RangeSize;
                case 4:
                    return RangeType;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ModuleRange> m_target;
        #endregion
    }
    public sealed class ClrStackWalk : TraceEvent
    {
        public int ClrInstanceID { get { return GetInt16At(0); } }
        // Skipping Reserved1
        // Skipping Reserved2
        public int FrameCount { get { return GetInt32At(4); } }
        public Address Stack { get { return GetAddressAt(8); } }

        #region Private
        internal ClrStackWalk(Action<ClrStackWalk> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(16, 1)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(16, 1)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ClrStackWalk>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttrib(sb, "FrameCount", FrameCount);
             XmlAttribHex(sb, "Stack", Stack);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ClrInstanceID", "FrameCount", "Stack"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ClrInstanceID;
                case 1:
                    return FrameCount;
                case 2:
                    return Stack;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ClrStackWalk> m_target;
        #endregion
    }
    public sealed class EmptyTraceData : TraceEvent
    {
        public ContentionFlags ContentionFlags { get { if (Version >= 1) return (ContentionFlags)GetByteAt(0); return (ContentionFlags)0; } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(1); return 0; } }

        #region Private
        internal EmptyTraceData(Action<EmptyTraceData> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 1 && EventDataLength != 3));
            Debug.Assert(!(Version > 1 && EventDataLength < 3));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<EmptyTraceData>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ContentionFlags", ContentionFlags);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ContentionFlags", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ContentionFlags;
                case 1:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<EmptyTraceData> m_target;
        #endregion
    }
    public sealed class Contention : TraceEvent
    {
        public ContentionFlags ContentionFlags { get { return (ContentionFlags)GetByteAt(0); } }
        public int ClrInstanceID { get { return GetInt16At(1); } }

        #region Private
        internal Contention(Action<Contention> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 3));
            Debug.Assert(!(Version > 0 && EventDataLength < 3));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<Contention>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ContentionFlags", ContentionFlags);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ContentionFlags", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ContentionFlags;
                case 1:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<Contention> m_target;
        #endregion
    }
    public sealed class GCAllocationTick : TraceEvent
    {
        public int AllocationAmount { get { return GetInt32At(0); } }
        public GCAllocationKind AllocationKind { get { return (GCAllocationKind)GetInt32At(4); } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(8); return 0; } }
        public long AllocationAmount64 { get { if (Version >= 2) return GetInt64At(10); return 0; } }
        public Address TypeID { get { if (Version >= 2) return GetAddressAt(18); return 0; } }
        public string TypeName { get { if (Version >= 2) return GetUnicodeStringAt(HostOffset(22, 1)); return ""; } }
        public int HeapIndex { get { if (Version >= 2) return GetInt32At(SkipUnicodeString(HostOffset(22, 1))); return 0; } }
        public Address Address { get { if (Version >= 3) return GetAddressAt(SkipUnicodeString(HostOffset(22, 1))+4); return 0; } }

        #region Private
        internal GCAllocationTick(Action<GCAllocationTick> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 8));
            Debug.Assert(!(Version == 1 && EventDataLength != 10));
            Debug.Assert(!(Version == 2 && EventDataLength != SkipUnicodeString(HostOffset(22, 1))+4));
            Debug.Assert(!(Version == 3 && EventDataLength != HostOffset(SkipUnicodeString(HostOffset(22, 1))+8, 1)));
            Debug.Assert(!(Version > 3 && EventDataLength < HostOffset(SkipUnicodeString(HostOffset(22, 1))+8, 1)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCAllocationTick>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "AllocationAmount", AllocationAmount);
             XmlAttrib(sb, "AllocationKind", AllocationKind);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttrib(sb, "AllocationAmount64", AllocationAmount64);
             XmlAttribHex(sb, "TypeID", TypeID);
             XmlAttrib(sb, "TypeName", TypeName);
             XmlAttrib(sb, "HeapIndex", HeapIndex);
             XmlAttribHex(sb, "Address", Address);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "AllocationAmount", "AllocationKind", "ClrInstanceID", "AllocationAmount64", "TypeID", "TypeName", "HeapIndex", "Address"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return AllocationAmount;
                case 1:
                    return AllocationKind;
                case 2:
                    return ClrInstanceID;
                case 3:
                    return AllocationAmount64;
                case 4:
                    return TypeID;
                case 5:
                    return TypeName;
                case 6:
                    return HeapIndex;
                case 7:
                    return Address;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCAllocationTick> m_target;
        #endregion
    }
    public sealed class GCCreateSegment : TraceEvent
    {
        public long Address { get { return GetInt64At(0); } }
        public long Size { get { return GetInt64At(8); } }
        public GCSegmentType Type { get { return (GCSegmentType)GetInt32At(16); } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(20); return 0; } }

        #region Private
        internal GCCreateSegment(Action<GCCreateSegment> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 20));
            Debug.Assert(!(Version == 1 && EventDataLength != 22));
            Debug.Assert(!(Version > 1 && EventDataLength < 22));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCCreateSegment>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Address", Address);
             XmlAttrib(sb, "Size", Size);
             XmlAttrib(sb, "Type", Type);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Address", "Size", "Type", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Address;
                case 1:
                    return Size;
                case 2:
                    return Type;
                case 3:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCCreateSegment> m_target;
        #endregion
    }
    public sealed class DecreaseMemoryPressure : TraceEvent
    {
        public long BytesFreed { get { return GetInt64At(0); } }
        public int ClrInstanceID { get { return GetInt16At(8); } }

        #region Private
        internal DecreaseMemoryPressure(Action<DecreaseMemoryPressure> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 10));
            Debug.Assert(!(Version > 0 && EventDataLength < 10));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<DecreaseMemoryPressure>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "BytesFreed", BytesFreed);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "BytesFreed", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return BytesFreed;
                case 1:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<DecreaseMemoryPressure> m_target;
        #endregion
    }
    public sealed class DestroyGCHandle : TraceEvent
    {
        public Address HandleID { get { return GetAddressAt(0); } }
        public int ClrInstanceID { get { return GetInt16At(HostOffset(4, 1)); } }

        #region Private
        internal DestroyGCHandle(Action<DestroyGCHandle> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(6, 1)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(6, 1)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<DestroyGCHandle>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttribHex(sb, "HandleID", HandleID);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "HandleID", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return HandleID;
                case 1:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<DestroyGCHandle> m_target;
        #endregion
    }
    public sealed class FinalizeObject : TraceEvent
    {
        public Address TypeID { get { return GetAddressAt(0); } }
        public Address ObjectID { get { return GetAddressAt(HostOffset(4, 1)); } }
        public int ClrInstanceID { get { return GetInt16At(HostOffset(8, 2)); } }

        #region Private
        internal FinalizeObject(Action<FinalizeObject> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(10, 2)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(10, 2)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<FinalizeObject>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttribHex(sb, "TypeID", TypeID);
             XmlAttribHex(sb, "ObjectID", ObjectID);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "TypeID", "ObjectID", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return TypeID;
                case 1:
                    return ObjectID;
                case 2:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<FinalizeObject> m_target;
        #endregion
    }
    public sealed class GCFinalizersEnd : TraceEvent
    {
        public int Count { get { return GetInt32At(0); } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(4); return 0; } }

        #region Private
        internal GCFinalizersEnd(Action<GCFinalizersEnd> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 4));
            Debug.Assert(!(Version == 1 && EventDataLength != 6));
            Debug.Assert(!(Version > 1 && EventDataLength < 6));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCFinalizersEnd>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Count", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Count;
                case 1:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCFinalizersEnd> m_target;
        #endregion
    }
    public sealed class GCFreeSegment : TraceEvent
    {
        public long Address { get { return GetInt64At(0); } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(8); return 0; } }

        #region Private
        internal GCFreeSegment(Action<GCFreeSegment> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 8));
            Debug.Assert(!(Version == 1 && EventDataLength != 10));
            Debug.Assert(!(Version > 1 && EventDataLength < 10));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCFreeSegment>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Address", Address);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Address", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Address;
                case 1:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCFreeSegment> m_target;
        #endregion
    }
    public sealed class GCBulkEdge : TraceEvent
    {
        public int Index { get { return GetInt32At(0); } }
        public int Count { get { return GetInt32At(4); } }
        public int ClrInstanceID { get { return GetInt16At(8); } }
        public Address Value { get { return GetAddressAt(10); } }
        public int ReferencingFieldID { get { return GetInt32At(HostOffset(14, 1)); } }

        #region Private
        internal GCBulkEdge(Action<GCBulkEdge> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(18, 1)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(18, 1)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCBulkEdge>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Index", Index);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttribHex(sb, "Value", Value);
             XmlAttrib(sb, "ReferencingFieldID", ReferencingFieldID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Index", "Count", "ClrInstanceID", "Value", "ReferencingFieldID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Index;
                case 1:
                    return Count;
                case 2:
                    return ClrInstanceID;
                case 3:
                    return Value;
                case 4:
                    return ReferencingFieldID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCBulkEdge> m_target;
        #endregion
    }
    public sealed class GCBulkMovedObjectRanges : TraceEvent
    {
        public int Index { get { return GetInt32At(0); } }
        public int Count { get { return GetInt32At(4); } }
        public int ClrInstanceID { get { return GetInt16At(8); } }
        public Address OldRangeBase { get { return GetAddressAt(10); } }
        public Address NewRangeBase { get { return GetAddressAt(HostOffset(14, 1)); } }
        public long RangeLength { get { return GetInt64At(HostOffset(18, 2)); } }

        #region Private
        internal GCBulkMovedObjectRanges(Action<GCBulkMovedObjectRanges> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(26, 2)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(26, 2)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCBulkMovedObjectRanges>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Index", Index);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttribHex(sb, "OldRangeBase", OldRangeBase);
             XmlAttribHex(sb, "NewRangeBase", NewRangeBase);
             XmlAttrib(sb, "RangeLength", RangeLength);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Index", "Count", "ClrInstanceID", "OldRangeBase", "NewRangeBase", "RangeLength"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Index;
                case 1:
                    return Count;
                case 2:
                    return ClrInstanceID;
                case 3:
                    return OldRangeBase;
                case 4:
                    return NewRangeBase;
                case 5:
                    return RangeLength;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCBulkMovedObjectRanges> m_target;
        #endregion
    }
    public sealed class GCBulkNode : TraceEvent
    {
        public int Index { get { return GetInt32At(0); } }
        public int Count { get { return GetInt32At(4); } }
        public int ClrInstanceID { get { return GetInt16At(8); } }
        public Address Address { get { return GetAddressAt(10); } }
        public long Size { get { return GetInt64At(HostOffset(14, 1)); } }
        public long TypeID { get { return GetInt64At(HostOffset(22, 1)); } }
        public long EdgeCount { get { return GetInt64At(HostOffset(30, 1)); } }

        #region Private
        internal GCBulkNode(Action<GCBulkNode> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(38, 1)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(38, 1)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCBulkNode>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Index", Index);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttribHex(sb, "Address", Address);
             XmlAttrib(sb, "Size", Size);
             XmlAttrib(sb, "TypeID", TypeID);
             XmlAttrib(sb, "EdgeCount", EdgeCount);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Index", "Count", "ClrInstanceID", "Address", "Size", "TypeID", "EdgeCount"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Index;
                case 1:
                    return Count;
                case 2:
                    return ClrInstanceID;
                case 3:
                    return Address;
                case 4:
                    return Size;
                case 5:
                    return TypeID;
                case 6:
                    return EdgeCount;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCBulkNode> m_target;
        #endregion
    }
    public sealed class GCBulkRCW : TraceEvent
    {
        public int Count { get { return GetInt32At(0); } }
        public int ClrInstanceID { get { return GetInt16At(4); } }
        public long ObjectID { get { return GetInt64At(6); } }
        public long TypeID { get { return GetInt64At(14); } }
        public long IUnknown { get { return GetInt64At(22); } }
        public long VTable { get { return GetInt64At(30); } }
        public int RefCount { get { return GetInt32At(38); } }
        public int Flags { get { return GetInt32At(42); } }

        #region Private
        internal GCBulkRCW(Action<GCBulkRCW> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 46));
            Debug.Assert(!(Version > 0 && EventDataLength < 46));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCBulkRCW>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttrib(sb, "ObjectID", ObjectID);
             XmlAttrib(sb, "TypeID", TypeID);
             XmlAttrib(sb, "IUnknown", IUnknown);
             XmlAttrib(sb, "VTable", VTable);
             XmlAttrib(sb, "RefCount", RefCount);
             XmlAttrib(sb, "Flags", Flags);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Count", "ClrInstanceID", "ObjectID", "TypeID", "IUnknown", "VTable", "RefCount", "Flags"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Count;
                case 1:
                    return ClrInstanceID;
                case 2:
                    return ObjectID;
                case 3:
                    return TypeID;
                case 4:
                    return IUnknown;
                case 5:
                    return VTable;
                case 6:
                    return RefCount;
                case 7:
                    return Flags;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCBulkRCW> m_target;
        #endregion
    }
    public sealed class GCBulkRootCCW : TraceEvent
    {
        public int Count { get { return GetInt32At(0); } }
        public int ClrInstanceID { get { return GetInt16At(4); } }
        public long GCRootID { get { return GetInt64At(6); } }
        public long ObjectID { get { return GetInt64At(14); } }
        public long TypeID { get { return GetInt64At(22); } }
        public long IUnknown { get { return GetInt64At(30); } }
        public int RefCount { get { return GetInt32At(38); } }
        public int PeggedRefCount { get { return GetInt32At(42); } }
        public GCRootCCWFlags Flags { get { return (GCRootCCWFlags)GetInt32At(46); } }

        #region Private
        internal GCBulkRootCCW(Action<GCBulkRootCCW> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 50));
            Debug.Assert(!(Version > 0 && EventDataLength < 50));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCBulkRootCCW>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttrib(sb, "GCRootID", GCRootID);
             XmlAttrib(sb, "ObjectID", ObjectID);
             XmlAttrib(sb, "TypeID", TypeID);
             XmlAttrib(sb, "IUnknown", IUnknown);
             XmlAttrib(sb, "RefCount", RefCount);
             XmlAttrib(sb, "PeggedRefCount", PeggedRefCount);
             XmlAttrib(sb, "Flags", Flags);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Count", "ClrInstanceID", "GCRootID", "ObjectID", "TypeID", "IUnknown", "RefCount", "PeggedRefCount", "Flags"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Count;
                case 1:
                    return ClrInstanceID;
                case 2:
                    return GCRootID;
                case 3:
                    return ObjectID;
                case 4:
                    return TypeID;
                case 5:
                    return IUnknown;
                case 6:
                    return RefCount;
                case 7:
                    return PeggedRefCount;
                case 8:
                    return Flags;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCBulkRootCCW> m_target;
        #endregion
    }
    public sealed class GCBulkRootConditionalWeakTableElementEdge : TraceEvent
    {
        public int Index { get { return GetInt32At(0); } }
        public int Count { get { return GetInt32At(4); } }
        public int ClrInstanceID { get { return GetInt16At(8); } }
        public Address GCKeyNodeID { get { return GetAddressAt(10); } }
        public Address GCValueNodeID { get { return GetAddressAt(HostOffset(14, 1)); } }
        public Address GCRootID { get { return GetAddressAt(HostOffset(18, 2)); } }

        #region Private
        internal GCBulkRootConditionalWeakTableElementEdge(Action<GCBulkRootConditionalWeakTableElementEdge> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(22, 3)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(22, 3)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCBulkRootConditionalWeakTableElementEdge>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Index", Index);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttribHex(sb, "GCKeyNodeID", GCKeyNodeID);
             XmlAttribHex(sb, "GCValueNodeID", GCValueNodeID);
             XmlAttribHex(sb, "GCRootID", GCRootID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Index", "Count", "ClrInstanceID", "GCKeyNodeID", "GCValueNodeID", "GCRootID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Index;
                case 1:
                    return Count;
                case 2:
                    return ClrInstanceID;
                case 3:
                    return GCKeyNodeID;
                case 4:
                    return GCValueNodeID;
                case 5:
                    return GCRootID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCBulkRootConditionalWeakTableElementEdge> m_target;
        #endregion
    }
    public sealed class GCBulkRootEdge : TraceEvent
    {
        public int Index { get { return GetInt32At(0); } }
        public int Count { get { return GetInt32At(4); } }
        public int ClrInstanceID { get { return GetInt16At(8); } }
        public Address RootedNodeAddress { get { return GetAddressAt(10); } }
        public GCRootKind GCRootKind { get { return (GCRootKind)GetByteAt(HostOffset(14, 1)); } }
        public GCRootFlags GCRootFlag { get { return (GCRootFlags)GetInt32At(HostOffset(15, 1)); } }
        public Address GCRootID { get { return GetAddressAt(HostOffset(19, 1)); } }

        #region Private
        internal GCBulkRootEdge(Action<GCBulkRootEdge> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(23, 2)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(23, 2)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCBulkRootEdge>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Index", Index);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttribHex(sb, "RootedNodeAddress", RootedNodeAddress);
             XmlAttrib(sb, "GCRootKind", GCRootKind);
             XmlAttrib(sb, "GCRootFlag", GCRootFlag);
             XmlAttribHex(sb, "GCRootID", GCRootID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Index", "Count", "ClrInstanceID", "RootedNodeAddress", "GCRootKind", "GCRootFlag", "GCRootID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Index;
                case 1:
                    return Count;
                case 2:
                    return ClrInstanceID;
                case 3:
                    return RootedNodeAddress;
                case 4:
                    return GCRootKind;
                case 5:
                    return GCRootFlag;
                case 6:
                    return GCRootID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCBulkRootEdge> m_target;
        #endregion
    }
    public sealed class GCBulkRootStaticVar : TraceEvent
    {
        public int Count { get { return GetInt32At(0); } }
        public long AppDomainID { get { return GetInt64At(4); } }
        public int ClrInstanceID { get { return GetInt16At(12); } }
        public long GCRootID { get { return GetInt64At(14); } }
        public long ObjectID { get { return GetInt64At(22); } }
        public long TypeID { get { return GetInt64At(30); } }
        public GCRootStaticVarFlags Flags { get { return (GCRootStaticVarFlags)GetInt32At(38); } }
        public string FieldName { get { return GetUnicodeStringAt(42); } }

        #region Private
        internal GCBulkRootStaticVar(Action<GCBulkRootStaticVar> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(42)));
            Debug.Assert(!(Version > 0 && EventDataLength < SkipUnicodeString(42)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCBulkRootStaticVar>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "AppDomainID", AppDomainID);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttrib(sb, "GCRootID", GCRootID);
             XmlAttrib(sb, "ObjectID", ObjectID);
             XmlAttrib(sb, "TypeID", TypeID);
             XmlAttrib(sb, "Flags", Flags);
             XmlAttrib(sb, "FieldName", FieldName);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Count", "AppDomainID", "ClrInstanceID", "GCRootID", "ObjectID", "TypeID", "Flags", "FieldName"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Count;
                case 1:
                    return AppDomainID;
                case 2:
                    return ClrInstanceID;
                case 3:
                    return GCRootID;
                case 4:
                    return ObjectID;
                case 5:
                    return TypeID;
                case 6:
                    return Flags;
                case 7:
                    return FieldName;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCBulkRootStaticVar> m_target;
        #endregion
    }
    public sealed class GCBulkSurvivingObjectRanges : TraceEvent
    {
        public int Index { get { return GetInt32At(0); } }
        public int Count { get { return GetInt32At(4); } }
        public int ClrInstanceID { get { return GetInt16At(8); } }
        public Address RangeBase { get { return GetAddressAt(10); } }
        public long RangeLength { get { return GetInt64At(HostOffset(14, 1)); } }

        #region Private
        internal GCBulkSurvivingObjectRanges(Action<GCBulkSurvivingObjectRanges> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(22, 1)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(22, 1)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCBulkSurvivingObjectRanges>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Index", Index);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttribHex(sb, "RangeBase", RangeBase);
             XmlAttrib(sb, "RangeLength", RangeLength);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Index", "Count", "ClrInstanceID", "RangeBase", "RangeLength"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Index;
                case 1:
                    return Count;
                case 2:
                    return ClrInstanceID;
                case 3:
                    return RangeBase;
                case 4:
                    return RangeLength;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCBulkSurvivingObjectRanges> m_target;
        #endregion
    }
    public sealed class GCGenerationRange : TraceEvent
    {
        public int Generation { get { return GetByteAt(0); } }
        public Address RangeStart { get { return GetAddressAt(1); } }
        public long RangeUsedLength { get { return GetInt64At(HostOffset(5, 1)); } }
        public long RangeReservedLength { get { return GetInt64At(HostOffset(13, 1)); } }
        public int ClrInstanceID { get { return GetInt16At(HostOffset(21, 1)); } }

        #region Private
        internal GCGenerationRange(Action<GCGenerationRange> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(23, 1)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(23, 1)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCGenerationRange>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Generation", Generation);
             XmlAttribHex(sb, "RangeStart", RangeStart);
             XmlAttrib(sb, "RangeUsedLength", RangeUsedLength);
             XmlAttrib(sb, "RangeReservedLength", RangeReservedLength);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Generation", "RangeStart", "RangeUsedLength", "RangeReservedLength", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Generation;
                case 1:
                    return RangeStart;
                case 2:
                    return RangeUsedLength;
                case 3:
                    return RangeReservedLength;
                case 4:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCGenerationRange> m_target;
        #endregion
    }
    public sealed class GCSampledObjectAllocation : TraceEvent
    {
        public Address Address { get { return GetAddressAt(0); } }
        public Address TypeID { get { return GetAddressAt(HostOffset(4, 1)); } }
        public int ObjectCountForTypeSample { get { return GetInt32At(HostOffset(8, 2)); } }
        public long TotalSizeForTypeSample { get { return GetInt64At(HostOffset(12, 2)); } }
        public int ClrInstanceID { get { return GetInt16At(HostOffset(20, 2)); } }

        #region Private
        internal GCSampledObjectAllocation(Action<GCSampledObjectAllocation> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(22, 2)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(22, 2)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCSampledObjectAllocation>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttribHex(sb, "Address", Address);
             XmlAttribHex(sb, "TypeID", TypeID);
             XmlAttrib(sb, "ObjectCountForTypeSample", ObjectCountForTypeSample);
             XmlAttrib(sb, "TotalSizeForTypeSample", TotalSizeForTypeSample);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Address", "TypeID", "ObjectCountForTypeSample", "TotalSizeForTypeSample", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Address;
                case 1:
                    return TypeID;
                case 2:
                    return ObjectCountForTypeSample;
                case 3:
                    return TotalSizeForTypeSample;
                case 4:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCSampledObjectAllocation> m_target;
        #endregion
    }
    public sealed class GCHeapStats : TraceEvent
    {
        public long GenerationSize0 { get { return GetInt64At(0); } }
        public long TotalPromotedSize0 { get { return GetInt64At(8); } }
        public long GenerationSize1 { get { return GetInt64At(16); } }
        public long TotalPromotedSize1 { get { return GetInt64At(24); } }
        public long GenerationSize2 { get { return GetInt64At(32); } }
        public long TotalPromotedSize2 { get { return GetInt64At(40); } }
        public long GenerationSize3 { get { return GetInt64At(48); } }
        public long TotalPromotedSize3 { get { return GetInt64At(56); } }
        public long FinalizationPromotedSize { get { return GetInt64At(64); } }
        public long FinalizationPromotedCount { get { return GetInt64At(72); } }
        public int PinnedObjectCount { get { return GetInt32At(80); } }
        public int SinkBlockCount { get { return GetInt32At(84); } }
        public int GCHandleCount { get { return GetInt32At(88); } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(92); return 0; } }

        #region Private
        internal GCHeapStats(Action<GCHeapStats> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 92));
            Debug.Assert(!(Version == 1 && EventDataLength != 94));
            Debug.Assert(!(Version > 1 && EventDataLength < 94));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCHeapStats>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "GenerationSize0", GenerationSize0);
             XmlAttrib(sb, "TotalPromotedSize0", TotalPromotedSize0);
             XmlAttrib(sb, "GenerationSize1", GenerationSize1);
             XmlAttrib(sb, "TotalPromotedSize1", TotalPromotedSize1);
             XmlAttrib(sb, "GenerationSize2", GenerationSize2);
             XmlAttrib(sb, "TotalPromotedSize2", TotalPromotedSize2);
             XmlAttrib(sb, "GenerationSize3", GenerationSize3);
             XmlAttrib(sb, "TotalPromotedSize3", TotalPromotedSize3);
             XmlAttrib(sb, "FinalizationPromotedSize", FinalizationPromotedSize);
             XmlAttrib(sb, "FinalizationPromotedCount", FinalizationPromotedCount);
             XmlAttrib(sb, "PinnedObjectCount", PinnedObjectCount);
             XmlAttrib(sb, "SinkBlockCount", SinkBlockCount);
             XmlAttrib(sb, "GCHandleCount", GCHandleCount);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "GenerationSize0", "TotalPromotedSize0", "GenerationSize1", "TotalPromotedSize1", "GenerationSize2", "TotalPromotedSize2", "GenerationSize3", "TotalPromotedSize3", "FinalizationPromotedSize", "FinalizationPromotedCount", "PinnedObjectCount", "SinkBlockCount", "GCHandleCount", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return GenerationSize0;
                case 1:
                    return TotalPromotedSize0;
                case 2:
                    return GenerationSize1;
                case 3:
                    return TotalPromotedSize1;
                case 4:
                    return GenerationSize2;
                case 5:
                    return TotalPromotedSize2;
                case 6:
                    return GenerationSize3;
                case 7:
                    return TotalPromotedSize3;
                case 8:
                    return FinalizationPromotedSize;
                case 9:
                    return FinalizationPromotedCount;
                case 10:
                    return PinnedObjectCount;
                case 11:
                    return SinkBlockCount;
                case 12:
                    return GCHandleCount;
                case 13:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCHeapStats> m_target;
        #endregion
    }
    public sealed class IncreaseMemoryPressure : TraceEvent
    {
        public long BytesAllocated { get { return GetInt64At(0); } }
        public int ClrInstanceID { get { return GetInt16At(8); } }

        #region Private
        internal IncreaseMemoryPressure(Action<IncreaseMemoryPressure> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 10));
            Debug.Assert(!(Version > 0 && EventDataLength < 10));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<IncreaseMemoryPressure>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "BytesAllocated", BytesAllocated);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "BytesAllocated", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return BytesAllocated;
                case 1:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<IncreaseMemoryPressure> m_target;
        #endregion
    }
    public sealed class GCMark : TraceEvent
    {
        public int HeapNum { get { return GetInt32At(0); } }
        public int ClrInstanceID { get { return GetInt16At(4); } }

        #region Private
        internal GCMark(Action<GCMark> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 6));
            Debug.Assert(!(Version > 0 && EventDataLength < 6));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCMark>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "HeapNum", HeapNum);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "HeapNum", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return HeapNum;
                case 1:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCMark> m_target;
        #endregion
    }
    public sealed class PinObjectAtGCTime : TraceEvent
    {
        public Address HandleID { get { return GetAddressAt(0); } }
        public Address ObjectID { get { return GetAddressAt(HostOffset(4, 1)); } }
        public long ObjectSize { get { return GetInt64At(HostOffset(8, 2)); } }
        public string TypeName { get { return GetUnicodeStringAt(HostOffset(16, 2)); } }
        public int ClrInstanceID { get { return GetInt16At(SkipUnicodeString(HostOffset(16, 2))); } }

        #region Private
        internal PinObjectAtGCTime(Action<PinObjectAtGCTime> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(HostOffset(16, 2))+2));
            Debug.Assert(!(Version > 0 && EventDataLength < SkipUnicodeString(HostOffset(16, 2))+2));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<PinObjectAtGCTime>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttribHex(sb, "HandleID", HandleID);
             XmlAttribHex(sb, "ObjectID", ObjectID);
             XmlAttrib(sb, "ObjectSize", ObjectSize);
             XmlAttrib(sb, "TypeName", TypeName);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "HandleID", "ObjectID", "ObjectSize", "TypeName", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return HandleID;
                case 1:
                    return ObjectID;
                case 2:
                    return ObjectSize;
                case 3:
                    return TypeName;
                case 4:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<PinObjectAtGCTime> m_target;
        #endregion
    }
    public sealed class SetGCHandle : TraceEvent
    {
        public Address HandleID { get { return GetAddressAt(0); } }
        public Address ObjectID { get { return GetAddressAt(HostOffset(4, 1)); } }
        public GCHandleKind Kind { get { return (GCHandleKind)GetInt32At(HostOffset(8, 2)); } }
        public int Generation { get { return GetInt32At(HostOffset(12, 2)); } }
        public long AppDomainID { get { return GetInt64At(HostOffset(16, 2)); } }
        public int ClrInstanceID { get { return GetInt16At(HostOffset(24, 2)); } }

        #region Private
        internal SetGCHandle(Action<SetGCHandle> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(26, 2)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(26, 2)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<SetGCHandle>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttribHex(sb, "HandleID", HandleID);
             XmlAttribHex(sb, "ObjectID", ObjectID);
             XmlAttrib(sb, "Kind", Kind);
             XmlAttrib(sb, "Generation", Generation);
             XmlAttrib(sb, "AppDomainID", AppDomainID);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "HandleID", "ObjectID", "Kind", "Generation", "AppDomainID", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return HandleID;
                case 1:
                    return ObjectID;
                case 2:
                    return Kind;
                case 3:
                    return Generation;
                case 4:
                    return AppDomainID;
                case 5:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<SetGCHandle> m_target;
        #endregion
    }
    public sealed class GCStart : TraceEvent
    {
        public int Count { get { return GetInt32At(0); } }
        public GCReason Reason { get { if (Version >= 1) return (GCReason)GetInt32At(8); return (GCReason)GetInt32At(4); } }
        public int Depth { get { if (Version >= 1) return GetInt32At(4); return 0; } }
        public GCType Type { get { if (Version >= 1) return (GCType)GetInt32At(12); return (GCType)0; } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(16); return 0; } }
        public long ClientSequenceNumber { get { if (Version >= 2) return GetInt64At(18); return 0; } }

        #region Private
        internal GCStart(Action<GCStart> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 8));
            Debug.Assert(!(Version == 1 && EventDataLength != 18));
            Debug.Assert(!(Version == 2 && EventDataLength != 26));
            Debug.Assert(!(Version > 2 && EventDataLength < 26));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCStart>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "Reason", Reason);
             XmlAttrib(sb, "Depth", Depth);
             XmlAttrib(sb, "Type", Type);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttrib(sb, "ClientSequenceNumber", ClientSequenceNumber);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Count", "Reason", "Depth", "Type", "ClrInstanceID", "ClientSequenceNumber"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Count;
                case 1:
                    return Reason;
                case 2:
                    return Depth;
                case 3:
                    return Type;
                case 4:
                    return ClrInstanceID;
                case 5:
                    return ClientSequenceNumber;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCStart> m_target;
        #endregion
    }
    public sealed class GCEnd : TraceEvent
    {
        public int Count { get { return GetInt32At(0); } }
        public int Depth { get { if (Version >= 1) return GetInt32At(4); return GetInt16At(4); } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(8); return 0; } }

        #region Private
        internal GCEnd(Action<GCEnd> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 6));
            Debug.Assert(!(Version == 1 && EventDataLength != 10));
            Debug.Assert(!(Version > 1 && EventDataLength < 10));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCEnd>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "Depth", Depth);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Count", "Depth", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Count;
                case 1:
                    return Depth;
                case 2:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCEnd> m_target;
        #endregion
    }
    public sealed class GCSuspendEE : TraceEvent
    {
        public GCSuspendEEReason Reason { get { if (Version >= 1) return (GCSuspendEEReason)GetInt32At(0); return (GCSuspendEEReason)GetInt16At(0); } }
        public int Count { get { if (Version >= 1) return GetInt32At(4); return 0; } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(8); return 0; } }

        #region Private
        internal GCSuspendEE(Action<GCSuspendEE> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 2));
            Debug.Assert(!(Version == 1 && EventDataLength != 10));
            Debug.Assert(!(Version > 1 && EventDataLength < 10));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCSuspendEE>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Reason", Reason);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Reason", "Count", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Reason;
                case 1:
                    return Count;
                case 2:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCSuspendEE> m_target;
        #endregion
    }
    public sealed class GCTriggered : TraceEvent
    {
        public GCReason Reason { get { return (GCReason)GetInt32At(0); } }
        public int ClrInstanceID { get { return GetInt16At(4); } }

        #region Private
        internal GCTriggered(Action<GCTriggered> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 6));
            Debug.Assert(!(Version > 0 && EventDataLength < 6));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<GCTriggered>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Reason", Reason);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Reason", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Reason;
                case 1:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<GCTriggered> m_target;
        #endregion
    }
    public sealed class ILStubCacheHit : TraceEvent
    {
        public int ClrInstanceID { get { return GetInt16At(0); } }
        public long ModuleID { get { return GetInt64At(2); } }
        public long StubMethodID { get { return GetInt64At(10); } }
        public int ManagedInteropMethodToken { get { return GetInt32At(18); } }
        public string ManagedInteropMethodNamespace { get { return GetUnicodeStringAt(22); } }
        public string ManagedInteropMethodName { get { return GetUnicodeStringAt(SkipUnicodeString(22)); } }
        public string ManagedInteropMethodSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(22))); } }

        #region Private
        internal ILStubCacheHit(Action<ILStubCacheHit> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(22)))));
            Debug.Assert(!(Version > 0 && EventDataLength < SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(22)))));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ILStubCacheHit>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttrib(sb, "ModuleID", ModuleID);
             XmlAttrib(sb, "StubMethodID", StubMethodID);
             XmlAttrib(sb, "ManagedInteropMethodToken", ManagedInteropMethodToken);
             XmlAttrib(sb, "ManagedInteropMethodNamespace", ManagedInteropMethodNamespace);
             XmlAttrib(sb, "ManagedInteropMethodName", ManagedInteropMethodName);
             XmlAttrib(sb, "ManagedInteropMethodSignature", ManagedInteropMethodSignature);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ClrInstanceID", "ModuleID", "StubMethodID", "ManagedInteropMethodToken", "ManagedInteropMethodNamespace", "ManagedInteropMethodName", "ManagedInteropMethodSignature"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ClrInstanceID;
                case 1:
                    return ModuleID;
                case 2:
                    return StubMethodID;
                case 3:
                    return ManagedInteropMethodToken;
                case 4:
                    return ManagedInteropMethodNamespace;
                case 5:
                    return ManagedInteropMethodName;
                case 6:
                    return ManagedInteropMethodSignature;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ILStubCacheHit> m_target;
        #endregion
    }
    public sealed class ILStubGenerated : TraceEvent
    {
        public int ClrInstanceID { get { return GetInt16At(0); } }
        public long ModuleID { get { return GetInt64At(2); } }
        public long StubMethodID { get { return GetInt64At(10); } }
        public ILStubGeneratedFlags StubFlags { get { return (ILStubGeneratedFlags)GetInt32At(18); } }
        public int ManagedInteropMethodToken { get { return GetInt32At(22); } }
        public string ManagedInteropMethodNamespace { get { return GetUnicodeStringAt(26); } }
        public string ManagedInteropMethodName { get { return GetUnicodeStringAt(SkipUnicodeString(26)); } }
        public string ManagedInteropMethodSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(26))); } }
        public string NativeMethodSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(26)))); } }
        public string StubMethodSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(26))))); } }
        public string StubMethodILCode { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(26)))))); } }

        #region Private
        internal ILStubGenerated(Action<ILStubGenerated> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(26))))))));
            Debug.Assert(!(Version > 0 && EventDataLength < SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(26))))))));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ILStubGenerated>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttrib(sb, "ModuleID", ModuleID);
             XmlAttrib(sb, "StubMethodID", StubMethodID);
             XmlAttrib(sb, "StubFlags", StubFlags);
             XmlAttrib(sb, "ManagedInteropMethodToken", ManagedInteropMethodToken);
             XmlAttrib(sb, "ManagedInteropMethodNamespace", ManagedInteropMethodNamespace);
             XmlAttrib(sb, "ManagedInteropMethodName", ManagedInteropMethodName);
             XmlAttrib(sb, "ManagedInteropMethodSignature", ManagedInteropMethodSignature);
             XmlAttrib(sb, "NativeMethodSignature", NativeMethodSignature);
             XmlAttrib(sb, "StubMethodSignature", StubMethodSignature);
             XmlAttrib(sb, "StubMethodILCode", StubMethodILCode);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ClrInstanceID", "ModuleID", "StubMethodID", "StubFlags", "ManagedInteropMethodToken", "ManagedInteropMethodNamespace", "ManagedInteropMethodName", "ManagedInteropMethodSignature", "NativeMethodSignature", "StubMethodSignature", "StubMethodILCode"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ClrInstanceID;
                case 1:
                    return ModuleID;
                case 2:
                    return StubMethodID;
                case 3:
                    return StubFlags;
                case 4:
                    return ManagedInteropMethodToken;
                case 5:
                    return ManagedInteropMethodNamespace;
                case 6:
                    return ManagedInteropMethodName;
                case 7:
                    return ManagedInteropMethodSignature;
                case 8:
                    return NativeMethodSignature;
                case 9:
                    return StubMethodSignature;
                case 10:
                    return StubMethodILCode;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ILStubGenerated> m_target;
        #endregion
    }
    public sealed class IOThread : TraceEvent
    {
        public int IOThreadCount { get { return GetInt32At(0); } }
        public int RetiredIOThreads { get { return GetInt32At(4); } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(8); return 0; } }

        #region Private
        internal IOThread(Action<IOThread> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 8));
            Debug.Assert(!(Version == 1 && EventDataLength != 10));
            Debug.Assert(!(Version > 1 && EventDataLength < 10));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<IOThread>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "IOThreadCount", IOThreadCount);
             XmlAttrib(sb, "RetiredIOThreads", RetiredIOThreads);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "IOThreadCount", "RetiredIOThreads", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return IOThreadCount;
                case 1:
                    return RetiredIOThreads;
                case 2:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<IOThread> m_target;
        #endregion
    }
    public sealed class AppDomainLoadUnload : TraceEvent
    {
        public long AppDomainID { get { return GetInt64At(0); } }
        public AppDomainFlags AppDomainFlags { get { return (AppDomainFlags)GetInt32At(8); } }
        public string AppDomainName { get { return GetUnicodeStringAt(12); } }
        public int AppDomainIndex { get { if (Version >= 1) return GetInt32At(SkipUnicodeString(12)); return 0; } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(SkipUnicodeString(12)+4); return 0; } }

        #region Private
        internal AppDomainLoadUnload(Action<AppDomainLoadUnload> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(12)));
            Debug.Assert(!(Version == 1 && EventDataLength != SkipUnicodeString(12)+6));
            Debug.Assert(!(Version > 1 && EventDataLength < SkipUnicodeString(12)+6));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<AppDomainLoadUnload>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "AppDomainID", AppDomainID);
             XmlAttrib(sb, "AppDomainFlags", AppDomainFlags);
             XmlAttrib(sb, "AppDomainName", AppDomainName);
             XmlAttrib(sb, "AppDomainIndex", AppDomainIndex);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "AppDomainID", "AppDomainFlags", "AppDomainName", "AppDomainIndex", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return AppDomainID;
                case 1:
                    return AppDomainFlags;
                case 2:
                    return AppDomainName;
                case 3:
                    return AppDomainIndex;
                case 4:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<AppDomainLoadUnload> m_target;
        #endregion
    }
    public sealed class AssemblyLoadUnload : TraceEvent
    {
        public long AssemblyID { get { return GetInt64At(0); } }
        public long AppDomainID { get { return GetInt64At(8); } }
        public AssemblyFlags AssemblyFlags { get { if (Version >= 1) return (AssemblyFlags)GetInt32At(24); return (AssemblyFlags)GetInt32At(16); } }
        public string FullyQualifiedAssemblyName { get { if (Version >= 1) return GetUnicodeStringAt(28); return GetUnicodeStringAt(20); } }
        public long BindingID { get { if (Version >= 1) return GetInt64At(16); return 0; } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(SkipUnicodeString(28)); return 0; } }

        #region Private
        internal AssemblyLoadUnload(Action<AssemblyLoadUnload> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(20)));
            Debug.Assert(!(Version == 1 && EventDataLength != SkipUnicodeString(28)+2));
            Debug.Assert(!(Version > 1 && EventDataLength < SkipUnicodeString(28)+2));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<AssemblyLoadUnload>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "AssemblyID", AssemblyID);
             XmlAttrib(sb, "AppDomainID", AppDomainID);
             XmlAttrib(sb, "AssemblyFlags", AssemblyFlags);
             XmlAttrib(sb, "FullyQualifiedAssemblyName", FullyQualifiedAssemblyName);
             XmlAttrib(sb, "BindingID", BindingID);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "AssemblyID", "AppDomainID", "AssemblyFlags", "FullyQualifiedAssemblyName", "BindingID", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return AssemblyID;
                case 1:
                    return AppDomainID;
                case 2:
                    return AssemblyFlags;
                case 3:
                    return FullyQualifiedAssemblyName;
                case 4:
                    return BindingID;
                case 5:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<AssemblyLoadUnload> m_target;
        #endregion
    }
    public sealed class DomainModuleLoadUnload : TraceEvent
    {
        public long ModuleID { get { return GetInt64At(0); } }
        public long AssemblyID { get { return GetInt64At(8); } }
        public long AppDomainID { get { return GetInt64At(16); } }
        public ModuleFlags ModuleFlags { get { return (ModuleFlags)GetInt32At(24); } }
        // Skipping Reserved1
        public string ModuleILPath { get { return GetUnicodeStringAt(32); } }
        public string ModuleNativePath { get { return GetUnicodeStringAt(SkipUnicodeString(32)); } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(SkipUnicodeString(SkipUnicodeString(32))); return 0; } }

        #region Private
        internal DomainModuleLoadUnload(Action<DomainModuleLoadUnload> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(SkipUnicodeString(32))));
            Debug.Assert(!(Version == 1 && EventDataLength != SkipUnicodeString(SkipUnicodeString(32))+2));
            Debug.Assert(!(Version > 1 && EventDataLength < SkipUnicodeString(SkipUnicodeString(32))+2));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<DomainModuleLoadUnload>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ModuleID", ModuleID);
             XmlAttrib(sb, "AssemblyID", AssemblyID);
             XmlAttrib(sb, "AppDomainID", AppDomainID);
             XmlAttrib(sb, "ModuleFlags", ModuleFlags);
             XmlAttrib(sb, "ModuleILPath", ModuleILPath);
             XmlAttrib(sb, "ModuleNativePath", ModuleNativePath);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ModuleID", "AssemblyID", "AppDomainID", "ModuleFlags", "ModuleILPath", "ModuleNativePath", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ModuleID;
                case 1:
                    return AssemblyID;
                case 2:
                    return AppDomainID;
                case 3:
                    return ModuleFlags;
                case 4:
                    return ModuleILPath;
                case 5:
                    return ModuleNativePath;
                case 6:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<DomainModuleLoadUnload> m_target;
        #endregion
    }
    public sealed class ModuleLoadUnload : TraceEvent
    {
        public long ModuleID { get { return GetInt64At(0); } }
        public long AssemblyID { get { return GetInt64At(8); } }
        public ModuleFlags ModuleFlags { get { return (ModuleFlags)GetInt32At(16); } }
        // Skipping Reserved1
        public string ModuleILPath { get { return GetUnicodeStringAt(24); } }
        public string ModuleNativePath { get { return GetUnicodeStringAt(SkipUnicodeString(24)); } }

        #region Private
        internal ModuleLoadUnload(Action<ModuleLoadUnload> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(SkipUnicodeString(24))));
            Debug.Assert(!(Version > 0 && EventDataLength < SkipUnicodeString(SkipUnicodeString(24))));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ModuleLoadUnload>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ModuleID", ModuleID);
             XmlAttrib(sb, "AssemblyID", AssemblyID);
             XmlAttrib(sb, "ModuleFlags", ModuleFlags);
             XmlAttrib(sb, "ModuleILPath", ModuleILPath);
             XmlAttrib(sb, "ModuleNativePath", ModuleNativePath);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ModuleID", "AssemblyID", "ModuleFlags", "ModuleILPath", "ModuleNativePath"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ModuleID;
                case 1:
                    return AssemblyID;
                case 2:
                    return ModuleFlags;
                case 3:
                    return ModuleILPath;
                case 4:
                    return ModuleNativePath;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ModuleLoadUnload> m_target;
        #endregion
    }
    public sealed class MethodLoadUnload : TraceEvent
    {
        public long MethodID { get { return GetInt64At(0); } }
        public long ModuleID { get { return GetInt64At(8); } }
        public long MethodStartAddress { get { return GetInt64At(16); } }
        public int MethodSize { get { return GetInt32At(24); } }
        public int MethodToken { get { return GetInt32At(28); } }
        public MethodFlags MethodFlags { get { return (MethodFlags)GetInt32At(32); } }

        #region Private
        internal MethodLoadUnload(Action<MethodLoadUnload> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 36));
            Debug.Assert(!(Version > 0 && EventDataLength < 36));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<MethodLoadUnload>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "MethodID", MethodID);
             XmlAttrib(sb, "ModuleID", ModuleID);
             XmlAttrib(sb, "MethodStartAddress", MethodStartAddress);
             XmlAttrib(sb, "MethodSize", MethodSize);
             XmlAttrib(sb, "MethodToken", MethodToken);
             XmlAttrib(sb, "MethodFlags", MethodFlags);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "MethodID", "ModuleID", "MethodStartAddress", "MethodSize", "MethodToken", "MethodFlags"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return MethodID;
                case 1:
                    return ModuleID;
                case 2:
                    return MethodStartAddress;
                case 3:
                    return MethodSize;
                case 4:
                    return MethodToken;
                case 5:
                    return MethodFlags;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<MethodLoadUnload> m_target;
        #endregion
    }
    public sealed class MethodLoadUnloadVerbose : TraceEvent
    {
        public long MethodID { get { return GetInt64At(0); } }
        public long ModuleID { get { return GetInt64At(8); } }
        public long MethodStartAddress { get { return GetInt64At(16); } }
        public int MethodSize { get { return GetInt32At(24); } }
        public int MethodToken { get { return GetInt32At(28); } }
        public MethodFlags MethodFlags { get { return (MethodFlags)GetInt32At(32); } }
        public string MethodNamespace { get { return GetUnicodeStringAt(36); } }
        public string MethodName { get { return GetUnicodeStringAt(SkipUnicodeString(36)); } }
        public string MethodSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(36))); } }

        #region Private
        internal MethodLoadUnloadVerbose(Action<MethodLoadUnloadVerbose> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(36)))));
            Debug.Assert(!(Version > 0 && EventDataLength < SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(36)))));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<MethodLoadUnloadVerbose>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "MethodID", MethodID);
             XmlAttrib(sb, "ModuleID", ModuleID);
             XmlAttrib(sb, "MethodStartAddress", MethodStartAddress);
             XmlAttrib(sb, "MethodSize", MethodSize);
             XmlAttrib(sb, "MethodToken", MethodToken);
             XmlAttrib(sb, "MethodFlags", MethodFlags);
             XmlAttrib(sb, "MethodNamespace", MethodNamespace);
             XmlAttrib(sb, "MethodName", MethodName);
             XmlAttrib(sb, "MethodSignature", MethodSignature);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "MethodID", "ModuleID", "MethodStartAddress", "MethodSize", "MethodToken", "MethodFlags", "MethodNamespace", "MethodName", "MethodSignature"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return MethodID;
                case 1:
                    return ModuleID;
                case 2:
                    return MethodStartAddress;
                case 3:
                    return MethodSize;
                case 4:
                    return MethodToken;
                case 5:
                    return MethodFlags;
                case 6:
                    return MethodNamespace;
                case 7:
                    return MethodName;
                case 8:
                    return MethodSignature;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<MethodLoadUnloadVerbose> m_target;
        #endregion
    }
    public sealed class MethodJitInliningFailed : TraceEvent
    {
        public string MethodBeingCompiledNamespace { get { return GetUnicodeStringAt(0); } }
        public string MethodBeingCompiledName { get { return GetUnicodeStringAt(SkipUnicodeString(0)); } }
        public string MethodBeingCompiledNameSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(0))); } }
        public string InlinerNamespace { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))); } }
        public string InlinerName { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0))))); } }
        public string InlinerNameSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))); } }
        public string InlineeNamespace { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0))))))); } }
        public string InlineeName { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))); } }
        public string InlineeNameSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0))))))))); } }
        public bool FailAlways { get { return GetInt32At(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))) != 0; } }
        public string FailReason { get { return GetUTF8StringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))+4); } }
        public int ClrInstanceID { get { return GetInt16At(SkipUTF8String(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))+4)); } }

        #region Private
        internal MethodJitInliningFailed(Action<MethodJitInliningFailed> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUTF8String(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))+4)+2));
            Debug.Assert(!(Version > 0 && EventDataLength < SkipUTF8String(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))+4)+2));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<MethodJitInliningFailed>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "MethodBeingCompiledNamespace", MethodBeingCompiledNamespace);
             XmlAttrib(sb, "MethodBeingCompiledName", MethodBeingCompiledName);
             XmlAttrib(sb, "MethodBeingCompiledNameSignature", MethodBeingCompiledNameSignature);
             XmlAttrib(sb, "InlinerNamespace", InlinerNamespace);
             XmlAttrib(sb, "InlinerName", InlinerName);
             XmlAttrib(sb, "InlinerNameSignature", InlinerNameSignature);
             XmlAttrib(sb, "InlineeNamespace", InlineeNamespace);
             XmlAttrib(sb, "InlineeName", InlineeName);
             XmlAttrib(sb, "InlineeNameSignature", InlineeNameSignature);
             XmlAttrib(sb, "FailAlways", FailAlways);
             XmlAttrib(sb, "FailReason", FailReason);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "MethodBeingCompiledNamespace", "MethodBeingCompiledName", "MethodBeingCompiledNameSignature", "InlinerNamespace", "InlinerName", "InlinerNameSignature", "InlineeNamespace", "InlineeName", "InlineeNameSignature", "FailAlways", "FailReason", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return MethodBeingCompiledNamespace;
                case 1:
                    return MethodBeingCompiledName;
                case 2:
                    return MethodBeingCompiledNameSignature;
                case 3:
                    return InlinerNamespace;
                case 4:
                    return InlinerName;
                case 5:
                    return InlinerNameSignature;
                case 6:
                    return InlineeNamespace;
                case 7:
                    return InlineeName;
                case 8:
                    return InlineeNameSignature;
                case 9:
                    return FailAlways;
                case 10:
                    return FailReason;
                case 11:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<MethodJitInliningFailed> m_target;
        #endregion
    }
    public sealed class MethodJitInliningSucceeded : TraceEvent
    {
        public string MethodBeingCompiledNamespace { get { return GetUnicodeStringAt(0); } }
        public string MethodBeingCompiledName { get { return GetUnicodeStringAt(SkipUnicodeString(0)); } }
        public string MethodBeingCompiledNameSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(0))); } }
        public string InlinerNamespace { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))); } }
        public string InlinerName { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0))))); } }
        public string InlinerNameSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))); } }
        public string InlineeNamespace { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0))))))); } }
        public string InlineeName { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))); } }
        public string InlineeNameSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0))))))))); } }
        public int ClrInstanceID { get { return GetInt16At(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))); } }

        #region Private
        internal MethodJitInliningSucceeded(Action<MethodJitInliningSucceeded> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))+2));
            Debug.Assert(!(Version > 0 && EventDataLength < SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))+2));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<MethodJitInliningSucceeded>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "MethodBeingCompiledNamespace", MethodBeingCompiledNamespace);
             XmlAttrib(sb, "MethodBeingCompiledName", MethodBeingCompiledName);
             XmlAttrib(sb, "MethodBeingCompiledNameSignature", MethodBeingCompiledNameSignature);
             XmlAttrib(sb, "InlinerNamespace", InlinerNamespace);
             XmlAttrib(sb, "InlinerName", InlinerName);
             XmlAttrib(sb, "InlinerNameSignature", InlinerNameSignature);
             XmlAttrib(sb, "InlineeNamespace", InlineeNamespace);
             XmlAttrib(sb, "InlineeName", InlineeName);
             XmlAttrib(sb, "InlineeNameSignature", InlineeNameSignature);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "MethodBeingCompiledNamespace", "MethodBeingCompiledName", "MethodBeingCompiledNameSignature", "InlinerNamespace", "InlinerName", "InlinerNameSignature", "InlineeNamespace", "InlineeName", "InlineeNameSignature", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return MethodBeingCompiledNamespace;
                case 1:
                    return MethodBeingCompiledName;
                case 2:
                    return MethodBeingCompiledNameSignature;
                case 3:
                    return InlinerNamespace;
                case 4:
                    return InlinerName;
                case 5:
                    return InlinerNameSignature;
                case 6:
                    return InlineeNamespace;
                case 7:
                    return InlineeName;
                case 8:
                    return InlineeNameSignature;
                case 9:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<MethodJitInliningSucceeded> m_target;
        #endregion
    }
    public sealed class MethodJittingStarted : TraceEvent
    {
        public long MethodID { get { return GetInt64At(0); } }
        public long ModuleID { get { return GetInt64At(8); } }
        public int MethodToken { get { return GetInt32At(16); } }
        public int MethodILSize { get { return GetInt32At(20); } }
        public string MethodNamespace { get { return GetUnicodeStringAt(24); } }
        public string MethodName { get { return GetUnicodeStringAt(SkipUnicodeString(24)); } }
        public string MethodSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(24))); } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(24)))); return 0; } }

        #region Private
        internal MethodJittingStarted(Action<MethodJittingStarted> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(24)))));
            Debug.Assert(!(Version == 1 && EventDataLength != SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(24)))+2));
            Debug.Assert(!(Version > 1 && EventDataLength < SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(24)))+2));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<MethodJittingStarted>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "MethodID", MethodID);
             XmlAttrib(sb, "ModuleID", ModuleID);
             XmlAttrib(sb, "MethodToken", MethodToken);
             XmlAttrib(sb, "MethodILSize", MethodILSize);
             XmlAttrib(sb, "MethodNamespace", MethodNamespace);
             XmlAttrib(sb, "MethodName", MethodName);
             XmlAttrib(sb, "MethodSignature", MethodSignature);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "MethodID", "ModuleID", "MethodToken", "MethodILSize", "MethodNamespace", "MethodName", "MethodSignature", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return MethodID;
                case 1:
                    return ModuleID;
                case 2:
                    return MethodToken;
                case 3:
                    return MethodILSize;
                case 4:
                    return MethodNamespace;
                case 5:
                    return MethodName;
                case 6:
                    return MethodSignature;
                case 7:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<MethodJittingStarted> m_target;
        #endregion
    }
    public sealed class MethodILToNativeMap : TraceEvent
    {
        public long MethodID { get { return GetInt64At(0); } }
        public long ReJITID { get { return GetInt64At(8); } }
        public int MethodExtent { get { return GetByteAt(16); } }
        public int CountOfMapEntries { get { return GetInt16At(17); } }
        public int ILOffsets(int arrayIndex) { return GetInt32At(19 + (arrayIndex * HostOffset(4, 0))); }
        public int NativeOffsets(int arrayIndex) { return GetInt32At(0+ (CountOfMapEntries*4)+19 + (arrayIndex * HostOffset(4, 0))); }
        public int ClrInstanceID { get { return GetInt16At(0+ (CountOfMapEntries*4)+ (CountOfMapEntries*4)+19); } }

        #region Private
        internal MethodILToNativeMap(Action<MethodILToNativeMap> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 0+ (CountOfMapEntries*4)+ (CountOfMapEntries*4)+21));
            Debug.Assert(!(Version > 0 && EventDataLength < 0+ (CountOfMapEntries*4)+ (CountOfMapEntries*4)+21));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<MethodILToNativeMap>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "MethodID", MethodID);
             XmlAttrib(sb, "ReJITID", ReJITID);
             XmlAttrib(sb, "MethodExtent", MethodExtent);
             XmlAttrib(sb, "CountOfMapEntries", CountOfMapEntries);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "MethodID", "ReJITID", "MethodExtent", "CountOfMapEntries", "ILOffsets", "NativeOffsets", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return MethodID;
                case 1:
                    return ReJITID;
                case 2:
                    return MethodExtent;
                case 3:
                    return CountOfMapEntries;
                case 4:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<MethodILToNativeMap> m_target;
        #endregion
    }
    public sealed class MethodJitTailCallFailed : TraceEvent
    {
        public string MethodBeingCompiledNamespace { get { return GetUnicodeStringAt(0); } }
        public string MethodBeingCompiledName { get { return GetUnicodeStringAt(SkipUnicodeString(0)); } }
        public string MethodBeingCompiledNameSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(0))); } }
        public string CallerNamespace { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))); } }
        public string CallerName { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0))))); } }
        public string CallerNameSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))); } }
        public string CalleeNamespace { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0))))))); } }
        public string CalleeName { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))); } }
        public string CalleeNameSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0))))))))); } }
        public bool TailPrefix { get { return GetInt32At(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))) != 0; } }
        public string FailReason { get { return GetUTF8StringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))+4); } }
        public int ClrInstanceID { get { return GetInt16At(SkipUTF8String(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))+4)); } }

        #region Private
        internal MethodJitTailCallFailed(Action<MethodJitTailCallFailed> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUTF8String(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))+4)+2));
            Debug.Assert(!(Version > 0 && EventDataLength < SkipUTF8String(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))+4)+2));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<MethodJitTailCallFailed>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "MethodBeingCompiledNamespace", MethodBeingCompiledNamespace);
             XmlAttrib(sb, "MethodBeingCompiledName", MethodBeingCompiledName);
             XmlAttrib(sb, "MethodBeingCompiledNameSignature", MethodBeingCompiledNameSignature);
             XmlAttrib(sb, "CallerNamespace", CallerNamespace);
             XmlAttrib(sb, "CallerName", CallerName);
             XmlAttrib(sb, "CallerNameSignature", CallerNameSignature);
             XmlAttrib(sb, "CalleeNamespace", CalleeNamespace);
             XmlAttrib(sb, "CalleeName", CalleeName);
             XmlAttrib(sb, "CalleeNameSignature", CalleeNameSignature);
             XmlAttrib(sb, "TailPrefix", TailPrefix);
             XmlAttrib(sb, "FailReason", FailReason);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "MethodBeingCompiledNamespace", "MethodBeingCompiledName", "MethodBeingCompiledNameSignature", "CallerNamespace", "CallerName", "CallerNameSignature", "CalleeNamespace", "CalleeName", "CalleeNameSignature", "TailPrefix", "FailReason", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return MethodBeingCompiledNamespace;
                case 1:
                    return MethodBeingCompiledName;
                case 2:
                    return MethodBeingCompiledNameSignature;
                case 3:
                    return CallerNamespace;
                case 4:
                    return CallerName;
                case 5:
                    return CallerNameSignature;
                case 6:
                    return CalleeNamespace;
                case 7:
                    return CalleeName;
                case 8:
                    return CalleeNameSignature;
                case 9:
                    return TailPrefix;
                case 10:
                    return FailReason;
                case 11:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<MethodJitTailCallFailed> m_target;
        #endregion
    }
    public sealed class MethodJitTailCallSucceeded : TraceEvent
    {
        public string MethodBeingCompiledNamespace { get { return GetUnicodeStringAt(0); } }
        public string MethodBeingCompiledName { get { return GetUnicodeStringAt(SkipUnicodeString(0)); } }
        public string MethodBeingCompiledNameSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(0))); } }
        public string CallerNamespace { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))); } }
        public string CallerName { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0))))); } }
        public string CallerNameSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))); } }
        public string CalleeNamespace { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0))))))); } }
        public string CalleeName { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))); } }
        public string CalleeNameSignature { get { return GetUnicodeStringAt(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0))))))))); } }
        public bool TailPrefix { get { return GetInt32At(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))) != 0; } }
        public TailCallType TailCallType { get { return (TailCallType)GetInt32At(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))+4); } }
        public int ClrInstanceID { get { return GetInt16At(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))+8); } }

        #region Private
        internal MethodJitTailCallSucceeded(Action<MethodJitTailCallSucceeded> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))+10));
            Debug.Assert(!(Version > 0 && EventDataLength < SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(SkipUnicodeString(0)))))))))+10));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<MethodJitTailCallSucceeded>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "MethodBeingCompiledNamespace", MethodBeingCompiledNamespace);
             XmlAttrib(sb, "MethodBeingCompiledName", MethodBeingCompiledName);
             XmlAttrib(sb, "MethodBeingCompiledNameSignature", MethodBeingCompiledNameSignature);
             XmlAttrib(sb, "CallerNamespace", CallerNamespace);
             XmlAttrib(sb, "CallerName", CallerName);
             XmlAttrib(sb, "CallerNameSignature", CallerNameSignature);
             XmlAttrib(sb, "CalleeNamespace", CalleeNamespace);
             XmlAttrib(sb, "CalleeName", CalleeName);
             XmlAttrib(sb, "CalleeNameSignature", CalleeNameSignature);
             XmlAttrib(sb, "TailPrefix", TailPrefix);
             XmlAttrib(sb, "TailCallType", TailCallType);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "MethodBeingCompiledNamespace", "MethodBeingCompiledName", "MethodBeingCompiledNameSignature", "CallerNamespace", "CallerName", "CallerNameSignature", "CalleeNamespace", "CalleeName", "CalleeNameSignature", "TailPrefix", "TailCallType", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return MethodBeingCompiledNamespace;
                case 1:
                    return MethodBeingCompiledName;
                case 2:
                    return MethodBeingCompiledNameSignature;
                case 3:
                    return CallerNamespace;
                case 4:
                    return CallerName;
                case 5:
                    return CallerNameSignature;
                case 6:
                    return CalleeNamespace;
                case 7:
                    return CalleeName;
                case 8:
                    return CalleeNameSignature;
                case 9:
                    return TailPrefix;
                case 10:
                    return TailCallType;
                case 11:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<MethodJitTailCallSucceeded> m_target;
        #endregion
    }
    public sealed class RuntimeInformation : TraceEvent
    {
        public int ClrInstanceID { get { return GetInt16At(0); } }
        public RuntimeSku Sku { get { return (RuntimeSku)GetInt16At(2); } }
        public int BclMajorVersion { get { return GetInt16At(4); } }
        public int BclMinorVersion { get { return GetInt16At(6); } }
        public int BclBuildNumber { get { return GetInt16At(8); } }
        public int BclQfeNumber { get { return GetInt16At(10); } }
        public int VMMajorVersion { get { return GetInt16At(12); } }
        public int VMMinorVersion { get { return GetInt16At(14); } }
        public int VMBuildNumber { get { return GetInt16At(16); } }
        public int VMQfeNumber { get { return GetInt16At(18); } }
        public StartupFlags StartupFlags { get { return (StartupFlags)GetInt32At(20); } }
        public StartupMode StartupMode { get { return (StartupMode)GetByteAt(24); } }
        public string CommandLine { get { return GetUnicodeStringAt(25); } }
        public Guid ComObjectGuid { get { return GetGuidAt(SkipUnicodeString(25)); } }
        public string RuntimeDllPath { get { return GetUnicodeStringAt(SkipUnicodeString(25)+16); } }

        #region Private
        internal RuntimeInformation(Action<RuntimeInformation> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(SkipUnicodeString(25)+16)));
            Debug.Assert(!(Version > 0 && EventDataLength < SkipUnicodeString(SkipUnicodeString(25)+16)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<RuntimeInformation>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttrib(sb, "Sku", Sku);
             XmlAttrib(sb, "BclMajorVersion", BclMajorVersion);
             XmlAttrib(sb, "BclMinorVersion", BclMinorVersion);
             XmlAttrib(sb, "BclBuildNumber", BclBuildNumber);
             XmlAttrib(sb, "BclQfeNumber", BclQfeNumber);
             XmlAttrib(sb, "VMMajorVersion", VMMajorVersion);
             XmlAttrib(sb, "VMMinorVersion", VMMinorVersion);
             XmlAttrib(sb, "VMBuildNumber", VMBuildNumber);
             XmlAttrib(sb, "VMQfeNumber", VMQfeNumber);
             XmlAttrib(sb, "StartupFlags", StartupFlags);
             XmlAttrib(sb, "StartupMode", StartupMode);
             XmlAttrib(sb, "CommandLine", CommandLine);
             XmlAttrib(sb, "ComObjectGuid", ComObjectGuid);
             XmlAttrib(sb, "RuntimeDllPath", RuntimeDllPath);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ClrInstanceID", "Sku", "BclMajorVersion", "BclMinorVersion", "BclBuildNumber", "BclQfeNumber", "VMMajorVersion", "VMMinorVersion", "VMBuildNumber", "VMQfeNumber", "StartupFlags", "StartupMode", "CommandLine", "ComObjectGuid", "RuntimeDllPath"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ClrInstanceID;
                case 1:
                    return Sku;
                case 2:
                    return BclMajorVersion;
                case 3:
                    return BclMinorVersion;
                case 4:
                    return BclBuildNumber;
                case 5:
                    return BclQfeNumber;
                case 6:
                    return VMMajorVersion;
                case 7:
                    return VMMinorVersion;
                case 8:
                    return VMBuildNumber;
                case 9:
                    return VMQfeNumber;
                case 10:
                    return StartupFlags;
                case 11:
                    return StartupMode;
                case 12:
                    return CommandLine;
                case 13:
                    return ComObjectGuid;
                case 14:
                    return RuntimeDllPath;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<RuntimeInformation> m_target;
        #endregion
    }
    public sealed class StrongNameVerification : TraceEvent
    {
        public int VerificationFlags { get { return GetInt32At(0); } }
        public int ErrorCode { get { return GetInt32At(4); } }
        public string FullyQualifiedAssemblyName { get { return GetUnicodeStringAt(8); } }
        public int ClrInstanceID { get { if (Version >= 1) return GetInt16At(SkipUnicodeString(8)); return 0; } }

        #region Private
        internal StrongNameVerification(Action<StrongNameVerification> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(8)));
            Debug.Assert(!(Version == 1 && EventDataLength != SkipUnicodeString(8)+2));
            Debug.Assert(!(Version > 1 && EventDataLength < SkipUnicodeString(8)+2));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<StrongNameVerification>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "VerificationFlags", VerificationFlags);
             XmlAttrib(sb, "ErrorCode", ErrorCode);
             XmlAttrib(sb, "FullyQualifiedAssemblyName", FullyQualifiedAssemblyName);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "VerificationFlags", "ErrorCode", "FullyQualifiedAssemblyName", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return VerificationFlags;
                case 1:
                    return ErrorCode;
                case 2:
                    return FullyQualifiedAssemblyName;
                case 3:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<StrongNameVerification> m_target;
        #endregion
    }
    public sealed class ThreadStartWork : TraceEvent
    {
        public Address ID { get { return GetAddressAt(0); } }
        public int ClrInstanceID { get { return GetInt16At(HostOffset(4, 1)); } }

        #region Private
        internal ThreadStartWork(Action<ThreadStartWork> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(6, 1)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(6, 1)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ThreadStartWork>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttribHex(sb, "ID", ID);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ID", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ID;
                case 1:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ThreadStartWork> m_target;
        #endregion
    }
    public sealed class ThreadPoolWork : TraceEvent
    {
        public Address WorkID { get { return GetAddressAt(0); } }
        public int ClrInstanceID { get { return GetInt16At(HostOffset(4, 1)); } }

        #region Private
        internal ThreadPoolWork(Action<ThreadPoolWork> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(6, 1)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(6, 1)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ThreadPoolWork>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttribHex(sb, "WorkID", WorkID);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "WorkID", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return WorkID;
                case 1:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ThreadPoolWork> m_target;
        #endregion
    }
    public sealed class ThreadPoolIOWork : TraceEvent
    {
        public Address NativeOverlapped { get { return GetAddressAt(0); } }
        public Address Overlapped { get { return GetAddressAt(HostOffset(4, 1)); } }
        public int ClrInstanceID { get { return GetInt16At(HostOffset(8, 2)); } }

        #region Private
        internal ThreadPoolIOWork(Action<ThreadPoolIOWork> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(10, 2)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(10, 2)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ThreadPoolIOWork>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttribHex(sb, "NativeOverlapped", NativeOverlapped);
             XmlAttribHex(sb, "Overlapped", Overlapped);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "NativeOverlapped", "Overlapped", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return NativeOverlapped;
                case 1:
                    return Overlapped;
                case 2:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ThreadPoolIOWork> m_target;
        #endregion
    }
    public sealed class ThreadPoolIOWorkEnqueue : TraceEvent
    {
        public Address NativeOverlapped { get { return GetAddressAt(0); } }
        public Address Overlapped { get { return GetAddressAt(HostOffset(4, 1)); } }
        public bool MultiDequeues { get { return GetInt32At(HostOffset(8, 2)) != 0; } }
        public int ClrInstanceID { get { return GetInt16At(HostOffset(12, 2)); } }

        #region Private
        internal ThreadPoolIOWorkEnqueue(Action<ThreadPoolIOWorkEnqueue> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != HostOffset(14, 2)));
            Debug.Assert(!(Version > 0 && EventDataLength < HostOffset(14, 2)));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ThreadPoolIOWorkEnqueue>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttribHex(sb, "NativeOverlapped", NativeOverlapped);
             XmlAttribHex(sb, "Overlapped", Overlapped);
             XmlAttrib(sb, "MultiDequeues", MultiDequeues);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "NativeOverlapped", "Overlapped", "MultiDequeues", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return NativeOverlapped;
                case 1:
                    return Overlapped;
                case 2:
                    return MultiDequeues;
                case 3:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ThreadPoolIOWorkEnqueue> m_target;
        #endregion
    }
    public sealed class ClrThreadPoolSuspend : TraceEvent
    {
        public int ClrThreadID { get { return GetInt32At(0); } }
        public int CpuUtilization { get { return GetInt32At(4); } }

        #region Private
        internal ClrThreadPoolSuspend(Action<ClrThreadPoolSuspend> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 8));
            Debug.Assert(!(Version > 0 && EventDataLength < 8));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ClrThreadPoolSuspend>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ClrThreadID", ClrThreadID);
             XmlAttrib(sb, "CpuUtilization", CpuUtilization);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ClrThreadID", "CpuUtilization"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ClrThreadID;
                case 1:
                    return CpuUtilization;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ClrThreadPoolSuspend> m_target;
        #endregion
    }
    public sealed class ThreadPoolWorkerThreadAdjustmentAdjustment : TraceEvent
    {
        public double AverageThroughput { get { return GetDoubleAt(0); } }
        public int NewWorkerThreadCount { get { return GetInt32At(8); } }
        public ThreadAdjustmentReason Reason { get { return (ThreadAdjustmentReason)GetInt32At(12); } }
        public int ClrInstanceID { get { return GetInt16At(16); } }

        #region Private
        internal ThreadPoolWorkerThreadAdjustmentAdjustment(Action<ThreadPoolWorkerThreadAdjustmentAdjustment> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 18));
            Debug.Assert(!(Version > 0 && EventDataLength < 18));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ThreadPoolWorkerThreadAdjustmentAdjustment>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "AverageThroughput", AverageThroughput);
             XmlAttrib(sb, "NewWorkerThreadCount", NewWorkerThreadCount);
             XmlAttrib(sb, "Reason", Reason);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "AverageThroughput", "NewWorkerThreadCount", "Reason", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return AverageThroughput;
                case 1:
                    return NewWorkerThreadCount;
                case 2:
                    return Reason;
                case 3:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ThreadPoolWorkerThreadAdjustmentAdjustment> m_target;
        #endregion
    }
    public sealed class ThreadPoolWorkerThreadAdjustmentSample : TraceEvent
    {
        public double Throughput { get { return GetDoubleAt(0); } }
        public int ClrInstanceID { get { return GetInt16At(8); } }

        #region Private
        internal ThreadPoolWorkerThreadAdjustmentSample(Action<ThreadPoolWorkerThreadAdjustmentSample> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 10));
            Debug.Assert(!(Version > 0 && EventDataLength < 10));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ThreadPoolWorkerThreadAdjustmentSample>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Throughput", Throughput);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Throughput", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Throughput;
                case 1:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ThreadPoolWorkerThreadAdjustmentSample> m_target;
        #endregion
    }
    public sealed class ThreadPoolWorkerThreadAdjustmentStats : TraceEvent
    {
        public double Duration { get { return GetDoubleAt(0); } }
        public double Throughput { get { return GetDoubleAt(8); } }
        public double ThreadWave { get { return GetDoubleAt(16); } }
        public double ThroughputWave { get { return GetDoubleAt(24); } }
        public double ThroughputErrorEstimate { get { return GetDoubleAt(32); } }
        public double AverageThroughputErrorEstimate { get { return GetDoubleAt(40); } }
        public double ThroughputRatio { get { return GetDoubleAt(48); } }
        public double Confidence { get { return GetDoubleAt(56); } }
        public double NewControlSetting { get { return GetDoubleAt(64); } }
        public int NewThreadWaveMagnitude { get { return GetInt16At(72); } }
        public int ClrInstanceID { get { return GetInt16At(74); } }

        #region Private
        internal ThreadPoolWorkerThreadAdjustmentStats(Action<ThreadPoolWorkerThreadAdjustmentStats> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 76));
            Debug.Assert(!(Version > 0 && EventDataLength < 76));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ThreadPoolWorkerThreadAdjustmentStats>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Duration", Duration);
             XmlAttrib(sb, "Throughput", Throughput);
             XmlAttrib(sb, "ThreadWave", ThreadWave);
             XmlAttrib(sb, "ThroughputWave", ThroughputWave);
             XmlAttrib(sb, "ThroughputErrorEstimate", ThroughputErrorEstimate);
             XmlAttrib(sb, "AverageThroughputErrorEstimate", AverageThroughputErrorEstimate);
             XmlAttrib(sb, "ThroughputRatio", ThroughputRatio);
             XmlAttrib(sb, "Confidence", Confidence);
             XmlAttrib(sb, "NewControlSetting", NewControlSetting);
             XmlAttrib(sb, "NewThreadWaveMagnitude", NewThreadWaveMagnitude);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Duration", "Throughput", "ThreadWave", "ThroughputWave", "ThroughputErrorEstimate", "AverageThroughputErrorEstimate", "ThroughputRatio", "Confidence", "NewControlSetting", "NewThreadWaveMagnitude", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Duration;
                case 1:
                    return Throughput;
                case 2:
                    return ThreadWave;
                case 3:
                    return ThroughputWave;
                case 4:
                    return ThroughputErrorEstimate;
                case 5:
                    return AverageThroughputErrorEstimate;
                case 6:
                    return ThroughputRatio;
                case 7:
                    return Confidence;
                case 8:
                    return NewControlSetting;
                case 9:
                    return NewThreadWaveMagnitude;
                case 10:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ThreadPoolWorkerThreadAdjustmentStats> m_target;
        #endregion
    }
    public sealed class ThreadPoolWorkerThread : TraceEvent
    {
        public int ActiveWorkerThreadCount { get { return GetInt32At(0); } }
        public int RetiredWorkerThreadCount { get { return GetInt32At(4); } }
        public int ClrInstanceID { get { return GetInt16At(8); } }

        #region Private
        internal ThreadPoolWorkerThread(Action<ThreadPoolWorkerThread> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 10));
            Debug.Assert(!(Version > 0 && EventDataLength < 10));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ThreadPoolWorkerThread>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ActiveWorkerThreadCount", ActiveWorkerThreadCount);
             XmlAttrib(sb, "RetiredWorkerThreadCount", RetiredWorkerThreadCount);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ActiveWorkerThreadCount", "RetiredWorkerThreadCount", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ActiveWorkerThreadCount;
                case 1:
                    return RetiredWorkerThreadCount;
                case 2:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ThreadPoolWorkerThread> m_target;
        #endregion
    }
    public sealed class ThreadPoolWorkingThreadCount : TraceEvent
    {
        public int Count { get { return GetInt32At(0); } }
        public int ClrInstanceID { get { return GetInt16At(4); } }

        #region Private
        internal ThreadPoolWorkingThreadCount(Action<ThreadPoolWorkingThreadCount> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 6));
            Debug.Assert(!(Version > 0 && EventDataLength < 6));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ThreadPoolWorkingThreadCount>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Count", "ClrInstanceID"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Count;
                case 1:
                    return ClrInstanceID;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ThreadPoolWorkingThreadCount> m_target;
        #endregion
    }
    public sealed class BulkType : TraceEvent
    {
        public int Count { get { return GetInt32At(0); } }
        public int ClrInstanceID { get { return GetInt16At(4); } }
        public long TypeID { get { return GetInt64At(6); } }
        public long ModuleID { get { return GetInt64At(14); } }
        public int TypeNameID { get { return GetInt32At(22); } }
        public TypeFlags Flags { get { return (TypeFlags)GetInt32At(26); } }
        public int CorElementType { get { return GetByteAt(30); } }
        public string Name { get { return GetUnicodeStringAt(31); } }
        public int TypeParameterCount { get { return GetInt32At(SkipUnicodeString(31)); } }
        public long TypeParameters(int arrayIndex) { return GetInt64At(SkipUnicodeString(31)+4 + (arrayIndex * HostOffset(8, 0))); }

        #region Private
        internal BulkType(Action<BulkType> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(31)+4));
            Debug.Assert(!(Version > 0 && EventDataLength < SkipUnicodeString(31)+4));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<BulkType>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Count", Count);
             XmlAttrib(sb, "ClrInstanceID", ClrInstanceID);
             XmlAttrib(sb, "TypeID", TypeID);
             XmlAttrib(sb, "ModuleID", ModuleID);
             XmlAttrib(sb, "TypeNameID", TypeNameID);
             XmlAttrib(sb, "Flags", Flags);
             XmlAttrib(sb, "CorElementType", CorElementType);
             XmlAttrib(sb, "Name", Name);
             XmlAttrib(sb, "TypeParameterCount", TypeParameterCount);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "Count", "ClrInstanceID", "TypeID", "ModuleID", "TypeNameID", "Flags", "CorElementType", "Name", "TypeParameterCount", "TypeParameters"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return Count;
                case 1:
                    return ClrInstanceID;
                case 2:
                    return TypeID;
                case 3:
                    return ModuleID;
                case 4:
                    return TypeNameID;
                case 5:
                    return Flags;
                case 6:
                    return CorElementType;
                case 7:
                    return Name;
                case 8:
                    return TypeParameterCount;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<BulkType> m_target;
        #endregion
    }
    public sealed class ClrWorkerThread : TraceEvent
    {
        public int WorkerThreadCount { get { return GetInt32At(0); } }
        public int RetiredWorkerThreads { get { return GetInt32At(4); } }

        #region Private
        internal ClrWorkerThread(Action<ClrWorkerThread> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected internal override void Dispatch()
        {
            m_target(this);
        }
        protected internal override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 8));
            Debug.Assert(!(Version > 0 && EventDataLength < 8));
        }
        protected internal override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<ClrWorkerThread>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "WorkerThreadCount", WorkerThreadCount);
             XmlAttrib(sb, "RetiredWorkerThreads", RetiredWorkerThreads);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "WorkerThreadCount", "RetiredWorkerThreads"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return WorkerThreadCount;
                case 1:
                    return RetiredWorkerThreads;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ClrWorkerThread> m_target;
        #endregion
    }
    [Flags]
    public enum AppDomainFlags
    {
        Default = 0x1,
        Executable = 0x2,
        Shared = 0x4,
    }
    [Flags]
    public enum AssemblyFlags
    {
        DomainNeutral = 0x1,
        Dynamic = 0x2,
        Native = 0x4,
        Collectible = 0x8,
    }
    public enum ContentionFlags
    {
        Managed = 0x0,
        Native = 0x1,
    }
    [Flags]
    public enum ExceptionThrownFlags
    {
        HasInnerException = 0x1,
        Nested = 0x2,
        ReThrown = 0x4,
        CorruptedState = 0x8,
        CLSCompliant = 0x10,
    }
    public enum GCAllocationKind
    {
        Small = 0x0,
        Large = 0x1,
    }
    public enum GCHandleKind
    {
        WeakShort = 0x0,
        WeakLong = 0x1,
        Strong = 0x2,
        Pinned = 0x3,
        Variable = 0x4,
        RefCounted = 0x5,
        Dependent = 0x6,
        AsyncPinned = 0x7,
        SizedRef = 0x8,
    }
    public enum GCReason
    {
        AllocSmall = 0x0,
        Induced = 0x1,
        LowMemory = 0x2,
        Empty = 0x3,
        AllocLarge = 0x4,
        OutOfSpaceSmallObjectHeap = 0x5,
        OutOfSpaceLargeObjectHeap = 0x6,
        InducedNoForce = 0x7,
        Stress = 0x8,
        InducedLowMemory = 0x9,
    }
    [Flags]
    public enum GCRootCCWFlags
    {
        Strong = 0x1,
        Pegged = 0x2,
    }
    [Flags]
    public enum GCRootFlags
    {
        Pinning = 0x1,
        WeakRef = 0x2,
        Interior = 0x4,
        RefCounted = 0x8,
    }
    public enum GCRootKind
    {
        Stack = 0x0,
        Finalizer = 0x1,
        Handle = 0x2,
        Other = 0x3,
    }
    [Flags]
    public enum GCRootStaticVarFlags
    {
        ThreadLocal = 0x1,
    }
    public enum GCSegmentType
    {
        SmallObjectHeap = 0x0,
        LargeObjectHeap = 0x1,
        ReadOnlyHeap = 0x2,
    }
    public enum GCSuspendEEReason
    {
        SuspendOther = 0x0,
        SuspendForGC = 0x1,
        SuspendForAppDomainShutdown = 0x2,
        SuspendForCodePitching = 0x3,
        SuspendForShutdown = 0x4,
        SuspendForDebugger = 0x5,
        SuspendForGCPrep = 0x6,
        SuspendForDebuggerSweep = 0x7,
    }
    public enum GCType
    {
        NonConcurrentGC = 0x0,
        BackgroundGC = 0x1,
        ForegroundGC = 0x2,
    }
    [Flags]
    public enum ILStubGeneratedFlags
    {
        ReverseInterop = 0x1,
        ComInterop = 0x2,
        NGenedStub = 0x4,
        Delegate = 0x8,
        VarArg = 0x10,
        UnmanagedCallee = 0x20,
    }
    [Flags]
    public enum MethodFlags
    {
        Dynamic = 0x1,
        Generic = 0x2,
        HasSharedGenericCode = 0x4,
        Jitted = 0x8,
        JitHelperMethod = 0x10,
    }
    [Flags]
    public enum ModuleFlags
    {
        DomainNeutral = 0x1,
        Native = 0x2,
        Dynamic = 0x4,
        Manifest = 0x8,
    }
    [Flags]
    public enum ModuleRangeType
    {
        ColdRange = 0x4,
    }
    [Flags]
    public enum RuntimeSku
    {
        DesktopClr = 0x1,
        CoreClr = 0x2,
    }
    [Flags]
    public enum StartupFlags
    {
        CONCURRENT_GC = 0x1,
        LOADER_OPTIMIZATION_SINGLE_DOMAIN = 0x2,
        LOADER_OPTIMIZATION_MULTI_DOMAIN = 0x4,
        LOADER_SAFEMODE = 0x10,
        LOADER_SETPREFERENCE = 0x100,
        SERVER_GC = 0x1000,
        HOARD_GC_VM = 0x2000,
        SINGLE_VERSION_HOSTING_INTERFACE = 0x4000,
        LEGACY_IMPERSONATION = 0x10000,
        DISABLE_COMMITTHREADSTACK = 0x20000,
        ALWAYSFLOW_IMPERSONATION = 0x40000,
        TRIM_GC_COMMIT = 0x80000,
        ETW = 0x100000,
        SERVER_BUILD = 0x200000,
        ARM = 0x400000,
    }
    [Flags]
    public enum StartupMode
    {
        ManagedExe = 0x1,
        HostedClr = 0x2,
        IjwDll = 0x4,
        ComActivated = 0x8,
        Other = 0x10,
    }
    public enum TailCallType
    {
        OptimizedTailCall = 0x0,
        RecursiveLoop = 0x1,
        HelperAssistedTailCall = 0x2,
    }
    public enum ThreadAdjustmentReason
    {
        Warmup = 0x0,
        Initializing = 0x1,
        RandomMove = 0x2,
        ClimbingMove = 0x3,
        ChangePoint = 0x4,
        Stabilizing = 0x5,
        Starvation = 0x6,
        ThreadTimedOut = 0x7,
    }
    [Flags]
    public enum ThreadFlags
    {
        GCSpecial = 0x1,
        Finalizer = 0x2,
        ThreadPoolWorker = 0x4,
    }
    [Flags]
    public enum TypeFlags
    {
        Delegate = 0x1,
        Finalizable = 0x2,
        ExternallyImplementedCOMObject = 0x4,
        Array = 0x8,
    }
}
